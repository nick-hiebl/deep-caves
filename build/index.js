"use strict";(()=>{var Mt=s=>{let t=s;return(e,{onLock:i,onRelease:o})=>{e!==t&&(t=e,e?i&&i():o&&o())}},v=(s,t)=>{let e=0;return{up(i=1){e=Math.min(1,e+i/s)},down(i=1){e=Math.max(0,e-i/t)},check(){return e}}};function ft(s,t,e){return(1-e)*s+e*t}function Y(s,t){return Math.floor((t-s)*Math.random())}function b(s,t){return s+Math.random()*(t-s)}function f(s,t){return!(s.x>=t.x+t.width||t.x>=s.x+s.width||s.y>=t.y+t.height||t.y>=s.y+s.height)}function k(s,t,e){return s.x<=t&&t<s.x+s.width&&s.y<=e&&e<s.y+s.height}function z(s){return s*s}function E(s,t,e){return s>t?Math.min(s,t+e):s<t?Math.max(s,t-e):s}function Tt(s,t,e){return Math.max(t,Math.min(s,e))}function Vt(s,t){return{x:Tt(s.x,t.x,t.x+t.width),y:Tt(s.y,t.y,t.y+t.height)}}function It(s,t){return{x:s.x+t,y:s.y+t,width:s.width-2*t,height:s.height-2*t}}function G(s){return{x:s.x+s.width/2,y:s.y+s.height/2}}function yt(s,t){let e=Math.sqrt(s.x*s.x+s.y*s.y);return{x:s.x*t/e,y:s.y*t/e}}function gt(s,t){return Math.sqrt(z(s.x-t.x)+z(s.y-t.y))}function vt(s){let t=s.width+s.height,e=b(0,t);return e<s.width?{x:s.x+e,y:Y(0,2)?s.y:s.y+s.height}:{x:Y(0,2)?s.x:s.x+s.width,y:s.y+(e-s.width)}}function _t(s){return{x:s.x+b(0,s.width),y:s.y+b(0,s.height)}}var c=class{x;y;height;width;isCollidable;isDroppable;color;xRemainder;yRemainder;blocker;constructor(t,e,i,o,r={}){this.x=t,this.y=e,this.width=i,this.height=o,this.isCollidable=!0,this.isDroppable=r.isDroppable??!1,this.blocker=!1,this.xRemainder=0,this.yRemainder=0}move(t,e,i,o){this.xRemainder+=t,this.yRemainder+=e;let r=Math.round(this.xRemainder),n=Math.round(this.yRemainder);if(r!==0||n!==0){let h=i.filter(l=>l.isRiding(this));if(this.isCollidable=!1,r!==0){if(this.xRemainder-=r,this.x+=r,r>0)for(let l of i)f(this,l)?l.moveX(this.x+this.width-l.x,l.squish,o):h.some(p=>p===l)&&l.moveX(r,()=>{},o);else if(r<0)for(let l of i)f(this,l)?l.moveX(this.x-(l.x+l.width),l.squish,o):h.some(p=>p===l)&&l.moveX(r,()=>{},o)}this.isCollidable=!0}}};var P=class{x;y;width;height;xRemainder;yRemainder;isDropping;droppingSet;constructor(t,e,i,o){this.x=t,this.y=e,this.width=i,this.height=o,this.xRemainder=0,this.yRemainder=0,this.isDropping=!1,this.droppingSet=new Set}setDropping(t){this.isDropping=!!t,this.droppingSet=new Set(Array.from(this.droppingSet).filter(e=>f(this,e)))}moveX(t,e,i){this.xRemainder+=t;let o=Math.round(this.xRemainder);if(o!==0){this.xRemainder-=o;let r=o>0?1:-1;for(;o!==0;){this.x+=r,o-=r;let{collidingSolid:n,droppingThroughSolids:h}=this.collideAt(i);if(h.forEach(l=>{this.droppingSet.add(l)}),n){this.x-=r,e(n);break}}}}moveY(t,e,i){this.yRemainder+=t;let o=Math.round(this.yRemainder);if(o!==0){this.yRemainder-=o;let r=o>0?1:-1;for(;o!==0;){this.y+=r,o-=r;let{collidingSolid:n,droppingThroughSolids:h}=this.collideAt(i);if((r<0||this.isDropping)&&h.length>0?h.forEach(l=>this.droppingSet.add(l)):h.length>0&&(n=h[0]),n){this.y-=r,e(n);break}}}}isGrounded(t){let e={x:this.x,y:this.y+this.height,width:this.width,height:1};return!!t.find(o=>this.droppingSet.has(o)||this.isDropping&&o.isDroppable?!1:f(e,o))}collideAt(t){let e=[];return{collidingSolid:t.find(o=>!o.isCollidable||!f(this,o)?!1:o.isDroppable?(this.droppingSet.has(o)||e.push(o),!1):!0),droppingThroughSolids:e}}isRiding(t){return k(t,this.x,this.y+this.height)||k(t,this.x+this.width-1,this.y+this.height)}squish(){console.log("Squish")}getMidpoint(){return{x:this.x+this.width/2,y:this.y+this.height/2}}};var A=s=>{let t=new Image;return t.src=s,t};var L=class{x;y;width;height;color;xVelocity;yVelocity;lifeLeft;lifespan;alive;affectedByGravity;constructor(t,e,i,o,r,n,h,l,p=!1){this.x=t,this.y=e,this.width=i,this.height=o,this.color=r,this.xVelocity=n,this.yVelocity=h,this.lifeLeft=l,this.lifespan=l,this.alive=!0,this.affectedByGravity=p}draw(t){t.filter=`opacity(${Math.round(100*this.lifeLeft/this.lifespan)}%)`,t.fillStyle=this.color,t.fillRect(Math.round(this.x),Math.round(this.y),this.width,this.height),t.filter="none"}update(t){this.affectedByGravity&&(this.yVelocity+=t*.0025),this.x+=t*this.xVelocity,this.y+=t*this.yVelocity,this.lifeLeft=Math.max(0,this.lifeLeft-t),this.lifeLeft<=0&&(this.alive=!1)}};var Ot=A("./img/sword_slash.png"),H=36,_=56,V=2,Pt=.7,j=class{facing;box;interactedWith;constructor(t){this.facing=t,this.box={width:_*V,height:H*V,x:t==="left"?-_*V*3/4:-_*V*1/4,y:-H*V/2},this.interactedWith=new Set}prePlayerDraw(t,e,i){let o=this.facing==="left"?0:_,r=e.x+this.box.x,n=e.y+this.box.y;t.globalAlpha=i,t.drawImage(Ot,o,0,_,H/2,r,n,_*V,H*V/2),t.globalAlpha=1}postPlayerDraw(t,e,i){let o=this.facing==="left"?0:_,r=e.x+this.box.x,n=e.y+this.box.y;t.globalAlpha=i,t.drawImage(Ot,o,H/2,_,H/2,r,n+H*V/2,_*V,H*V/2),t.globalAlpha=1,!1}getBox(t){return{x:t.x+this.box.x,y:t.y+this.box.y,width:this.box.width,height:this.box.height}}interactWithEnemy(t,e){if(this.interactedWith.has(e))return;let i=this.getBox(t),o=e.intersects(i);o&&(this.interactedWith.add(e),e.applyDamage(o,{x:this.facing==="left"?-Pt:Pt}))}};var q=class{preBufferDuration;coolDown;activeDuration;isPressed;timeSinceUnusedPress;isActive;timeSinceActivation;constructor(t,e,i){this.preBufferDuration=t,this.coolDown=e,this.activeDuration=i,this.isPressed=!1,this.timeSinceUnusedPress=void 0,this.isActive=!1,this.timeSinceActivation=Math.max(e,i)}update(t,e,i){this.isPressed?e&&(this.timeSinceUnusedPress=(this.timeSinceUnusedPress??0)+t):e?this.timeSinceUnusedPress=0:this.timeSinceUnusedPress=void 0,this.isPressed=!!e,(this.timeSinceActivation<this.activeDuration||this.timeSinceActivation<this.coolDown)&&(this.timeSinceActivation+=t),this.timeSinceActivation>=this.activeDuration&&(this.isActive=!1);let o=this.timeSinceUnusedPress!==void 0&&this.timeSinceUnusedPress<this.preBufferDuration;!this.isActive&&o&&this.timeSinceActivation>=this.coolDown&&(this.isActive=!0,this.timeSinceActivation=0,this.timeSinceUnusedPress=void 0,i())}fractionThroughCooldown(){if(this.isActive)return this.timeSinceActivation/this.activeDuration}};var Z=class{isGrounded;coyoteTime;timeSinceJumpPress;isJumpKeyDown;stillHoldingJump;constructor(){this.isGrounded=!1,this.coyoteTime=0,this.timeSinceJumpPress=200,this.isJumpKeyDown=!1,this.stillHoldingJump=!1}update(t,e,i){this.coyoteTime-=e,t[" "]?this.isJumpKeyDown?this.timeSinceJumpPress+=e:(this.isJumpKeyDown=!0,this.timeSinceJumpPress=0):(this.stillHoldingJump=!1,this.isJumpKeyDown=!1,this.timeSinceJumpPress=200);let r=this.isJumpKeyDown&&this.timeSinceJumpPress<100&&(this.isGrounded||this.coyoteTime>0);return r&&(this.stillHoldingJump=!0,this.timeSinceJumpPress=200,this.coyoteTime=0),{isJumping:r,yAcceleration:this.getGravity(i)}}getGravity(t){return t>-.5||!this.stillHoldingJump?.006:.0025}groundedCheck(t,e){this.isGrounded&&!t&&!e?this.coyoteTime=100:t&&(this.coyoteTime=0),this.isGrounded=t}};var $=14,bt=18,$t=450/1e3,Qt=8/1e3,te=1,ee=100,ie=250,oe=300,se="a",re="s",ne="d",he="j",ae=A("./img/sword_man.png"),le=(s,t,e)=>{let i=0,o=0;return t==="right"&&(i+=$*2),s&&(o+=bt*2),e&&(i+=$*4),{x:i,y:o}},Q=class{lastState;x;y;height;width;actor;xVelocity;yVelocity;facing;jumpController;attackController;attacks;constructor(t,e){t=Math.round(t),e=Math.round(e),this.lastState={x:t,y:e},this.x=t,this.y=e,this.height=bt*2,this.width=$*2,this.actor=new P(this.x-this.width,this.y-this.height,this.width*2,this.height*2),this.xVelocity=0,this.yVelocity=0,this.facing="left",this.jumpController=new Z,this.attackController=new q(oe,ie,ee),this.attacks=[]}draw(t,e,i,o){!1;let r=ft(this.lastState.x,this.x,o),n=ft(this.lastState.y,this.y,o),h=this.attackController.isActive,l=1-z(this.attackController.fractionThroughCooldown()??0);this.attacks.forEach(D=>{D.prePlayerDraw(t,{x:r,y:n},l)});let{x:p,y:g}=le(h,this.facing,!0);t.drawImage(ae,p,g,$*2,bt*2,r-this.width,n-this.height,this.width*2,this.height*2),this.attacks.forEach(D=>{D.postPlayerDraw(t,{x:r,y:n},l)}),!1}update(t,e,i,o){let r=o.solids,n=o.enemies;this.lastState={x:this.x,y:this.y},this.attackController.update(i,e[he],()=>{this.attacks=[new j(this.facing)]}),this.attackController.isActive||(this.attacks=[]),this.attacks.forEach(O=>{n.forEach(C=>{O.interactWithEnemy(this.lastState,C)})});let h=(e[ne]?1:0)-(e[se]?1:0),l=E(h*$t,this.xVelocity,Qt),{yAcceleration:p,isJumping:g}=this.jumpController.update(e,i,this.yVelocity);if(this.yVelocity+=p*i,g){for(let C=0;C<8;C++){let a=b(-1,1);o.addParticle(new L(this.actor.x+(1+a)*this.actor.width/2*1-2,this.actor.y+this.actor.height-2,4,4,"white",a*.3,(Math.random()<.6?1:-1)*b(.15,.2),140))}this.yVelocity=-te}this.xVelocity=l,h>0?this.facing="right":h<0&&(this.facing="left"),this.actor.setDropping(e[re]),this.actor.moveX(this.xVelocity*i,()=>{},r),this.actor.moveY(this.yVelocity*i,()=>{this.yVelocity=0},r),this.x=this.actor.x+this.width,this.y=this.actor.y+this.height;let D=this.actor.isGrounded(r);this.jumpController.groundedCheck(D,g)}};var tt=300/1e3,Lt=1/1e3,Ht=2/1e3,ce=A("./img/ghosty.png"),xt=24,kt=32,Ft=2,et=class{xVelocity;yVelocity;actor;hp;alive;facing;isNonPhysical;hurtVisualiser;constructor(t,e){this.xVelocity=0,this.yVelocity=0,this.actor=new P(t,e,xt*Ft,kt*Ft),this.hp=3,this.alive=!0,this.facing="left",this.isNonPhysical=!0,this.hurtVisualiser=v(1,250)}draw(t){this.hurtVisualiser.check()>0&&(t.filter="brightness(1000%) saturate(0%)"),t.drawImage(ce,this.facing==="left"?0:xt,0,xt,kt,this.actor.x,this.actor.y,this.actor.width,this.actor.height),t.filter="none",!1}update(t,e,i){this.updateVelocities(t,e,i),this.isNonPhysical?(this.actor.moveX(this.xVelocity*t,()=>{},[]),this.actor.moveY(this.yVelocity*t,()=>{},[])):(this.actor.moveX(this.xVelocity*t,()=>{this.xVelocity=0},e.solids),this.actor.moveY(this.yVelocity*t,()=>{this.yVelocity=0},e.solids)),this.hurtVisualiser.down(t)}updateVelocities(t,e,i){let o=this.actor.getMidpoint();i?(i.x<o.x?(this.xVelocity=E(-tt,this.xVelocity,Lt*t),this.facing="left"):(this.xVelocity=E(tt,this.xVelocity,Lt*t),this.facing="right"),i.y<o.y?this.yVelocity=E(-tt,this.yVelocity,Ht*t):this.yVelocity=E(tt,this.yVelocity,Ht*t)):this.facing=this.xVelocity<0?"left":"right"}applyDamage(t,e){this.hp-=1,this.xVelocity+=e?.x??0,this.yVelocity+=e?.y??0,this.hp<=0&&(this.alive=!1),this.hurtVisualiser.up()}intersects(t){if(f(t,this.actor))return this.actor}};var Bt=180/1e3,W=2/1e3,de=2.5/1e3,U=class extends et{constructor(t,e){super(t,e),this.hp=5,this.isNonPhysical=!1,this.facing="left"}updateVelocities(t,e,i){this.yVelocity+=de*t;let o={x:this.actor.x,y:this.actor.y+this.actor.height,width:this.actor.width,height:1};e.solids.some(r=>r.isCollidable&&f(r,o))||(this.xVelocity=E(0,this.xVelocity,W/2)),this.facing==="left"?this.canMoveLeft(e)?this.xVelocity=E(-Bt,this.xVelocity,W):this.canMoveRight(e)&&(this.facing="right",this.xVelocity=E(0,this.xVelocity,W)):this.canMoveRight(e)?this.xVelocity=E(Bt,this.xVelocity,W):this.canMoveLeft(e)&&(this.facing="left",this.xVelocity=E(0,this.xVelocity,W))}canMoveLeft(t){let e={x:this.actor.x-this.actor.width/2,y:this.actor.y+this.actor.height,width:this.actor.width/4,height:1},i={x:this.actor.x-this.actor.width,y:this.actor.y,height:this.actor.height,width:this.actor.width};return t.solids.some(o=>o.isCollidable&&!o.isDroppable&&f(o,e))&&t.solids.every(o=>!o.isCollidable||!f(o,i))}canMoveRight(t){let e={x:this.actor.x+this.actor.width/4*5,y:this.actor.y+this.actor.height,width:this.actor.width/4,height:1},i={x:this.actor.x+this.actor.width,y:this.actor.y,height:this.actor.height,width:this.actor.width};return t.solids.some(o=>o.isCollidable&&!o.isDroppable&&f(o,e))&&t.solids.every(o=>!o.isCollidable||o.isDroppable||!f(o,i))}applyDamage(t,e){super.applyDamage(t,e),this.yVelocity-=.3}};var wt=7e3,it=class{solid;timeTracked;constructor(t,e,i,o){this.solid=new c(t,e,i,o),this.timeTracked=0}update(t,e,i){this.timeTracked+=t;let o=this.timeTracked%wt,r=300+(o>wt/2?(wt-o)/7:o/7);this.solid.move(r-this.solid.x,0,e,i)}};var S=(s,t)=>{let e=s.x??s.left,i=s.y??s.top,o=s.width??s.right-e,r=s.height??s.bottom-i;if(isNaN(e)||isNaN(i)||isNaN(o)||isNaN(r))throw new Error("Invalid parameters to create solid!");return new c(e,i,o,r,t)},w=(s={})=>{let t=Object.keys(s).filter(e=>s[e]);return t.sort((e,i)=>u[e][0]-u[i][0]),t},Kt=s=>{let t=[];return t.push(...w(s.left).map(e=>u[e]).map(([e,i])=>S({top:e,bottom:i,left:0,width:y}))),t.push(...w(s.right).map(e=>u[e]).map(([e,i])=>S({top:e,bottom:i,left:d-y,width:y}))),t.push(...w(s.top).map(e=>u[e]).map(([e,i])=>S({left:e,right:i,top:0,height:y}))),t.push(...w(s.bottom).map(e=>u[e]).map(([e,i])=>S({left:e,right:i,top:m-y,height:y}))),t},M=s=>{let t=[],e=[],i=d/2-F/2,o=i+F,r=[0].concat(w(s.top).map(a=>u[a][1])),n=w(s.top).map(a=>u[a][0]).concat(d);t.push(...r.map((a,x)=>S({left:a,right:n[x],y:0,height:y}))),e.push(...w(s.top).map(a=>u[a]).map(([a,x])=>S({left:a,right:x,y:0,height:y})));let h=[0].concat(w(s.bottom).map(a=>u[a][1])),l=w(s.bottom).map(a=>u[a][0]).concat(d);t.push(...h.map((a,x)=>S({left:a,right:l[x],y:m-y,height:y}))),t.push(...w(s.bottom).map(a=>S({left:u[a][0],right:u[a][1],top:m-y,height:y/4},{isDroppable:!0}))),e.push(...w(s.bottom).map(a=>u[a]).map(([a,x])=>S({left:a,right:x,y:m-y,height:y})));let p=[0].concat(w(s.left).map(a=>u[a][1])),g=w(s.left).map(a=>u[a][0]).concat(m);t.push(...p.map((a,x)=>S({top:a,bottom:g[x],left:0,width:y}))),e.push(...w(s.left).map(a=>u[a]).map(([a,x])=>S({top:a,bottom:x,x:0,width:y})));let D=[0].concat(w(s.right).map(a=>u[a][1])),O=w(s.right).map(a=>u[a][0]).concat(m);t.push(...D.map((a,x)=>S({top:a,bottom:O[x],left:d-y,width:y}))),e.push(...w(s.right).map(a=>u[a]).map(([a,x])=>S({top:a,bottom:x,x:d-y,width:y})));let C=[];return C.push(S({left:i-F,width:F,top:420,height:y/4},{isDroppable:!0})),C.push(S({left:i-F,width:F,top:570,height:y/4},{isDroppable:!0})),C.push(S({left:i,right:o,top:140,height:y/4},{isDroppable:!0})),{blockers:e.map(a=>(a.blocker=!0,a.color="brown",a.isCollidable=!1,a)),solids:t,ladders:C}};var y=40,d=1280,m=720,F=y*6,u={high:[120,240],medium:[m/2-40,m/2+80],low:[m-160,m-40],left:[80,280],center:[d/2-100,d/2+100],right:[d-280,d-80]},Yt=["left","center","right"],Gt=["high","medium","low"];var R=class{getDoorwayChance(){return .5}static getDoorArrangement(){return{top:{},bottom:{},left:{},right:{}}}static isValidAt(t,e){return!0}static areDoorsOk(t){let e=this.getDoorArrangement();return Gt.every(i=>(e.left[i]===void 0||t.left[i]===void 0||e.left[i]===t.left[i])&&(e.right[i]===void 0||t.right[i]===void 0||e.right[i]===t.right[i]))&&Yt.every(i=>(e.top[i]===void 0||t.top[i]===void 0||e.top[i]===t.top[i])&&(e.bottom[i]===void 0||t.bottom[i]===void 0||e.bottom[i]===t.bottom[i]))}x;y;width;height;color;blockersLocked;allEnemiesCleared;doors;enemies;solids;interactives;particles;playerState;constructor(t,e,i,o,r="blue",n={}){this.x=t,this.y=e,this.width=i,this.height=o,this.color=r,this.blockersLocked=!1,this.allEnemiesCleared=!1,this.doors={left:n.left??{},right:n.right??{},top:n.top??{},bottom:n.bottom??{}},this.enemies=[],this.solids=[],this.interactives=[],this.particles=[],this.globalDoorwayRectification(),this.configureAllDoors(),this.configureRoomContent(),this.playerState=new Q(.5*d,.12*m)}globalDoorwayRectification(){this.x===0&&this.y===0?this.doors={bottom:{center:!0,left:!1,right:!1},top:{center:!1,left:!1,right:!1},left:{high:!1,medium:!1,low:!1},right:{high:!1,medium:!1,low:!1}}:this.x===0&&this.y===1?this.doors.top={center:!0,left:!1,right:!1}:this.y===1&&(this.doors.top={center:!1,left:!1,right:!1})}configureAllDoors(){let t=this.constructor.getDoorArrangement(),e=this.getDoorwayChance();Gt.forEach(i=>{this.doors.left[i]===void 0&&(this.doors.left[i]=t.left[i]??Math.random()<e),this.doors.right[i]===void 0&&(this.doors.right[i]=t.right[i]??Math.random()<e)}),Yt.forEach(i=>{this.doors.top[i]===void 0&&(this.doors.top[i]=t.top[i]??Math.random()<e),this.doors.bottom[i]===void 0&&(this.doors.bottom[i]=t.bottom[i]??Math.random()<e)})}configureRoomContent(){let{solids:t,blockers:e,ladders:i}=M(this.doors);this.solids=t.concat(e).concat(i),this.interactives=[new it(0,280,200,40)],this.solids.push(...this.interactives.map(o=>o.solid)),this.enemies=[]}draw(t,e,i,o){t.fillStyle="black",t.fillRect(0,0,e.width,e.height);for(let r of this.solids)r.color?t.fillStyle=r.color:t.fillStyle=this.color,t.fillRect(r.x,r.y,r.width,r.height);this.particles.forEach(r=>{r.draw(t)}),this.enemies.forEach(r=>{r.draw(t)}),t.fillStyle="white",this.playerState.draw(t,e,i,o)}update(t,e,i,o){this.blockersLocked||this.solids.some(r=>r.blocker&&f(this.playerState.actor,r))||(this.solids.forEach(r=>{r.blocker&&(r.isCollidable=!0)}),this.blockersLocked=!0),this.particles=this.particles.filter(r=>(r.update(i),r.alive)),this.interactives.forEach(r=>{r.update(i,[this.playerState.actor],this.solids)}),this.enemies.forEach(r=>{r.update(i,this,this.playerState.actor.getMidpoint())}),this.playerState.update(t,e,i,this),this.enemies=this.enemies.filter(r=>r.alive),!this.allEnemiesCleared&&this.enemies.length===0&&(this.onAllEnemiesCleared(),this.allEnemiesCleared=!0),this.validateLeavingRoom(o)}validateLeavingRoom(t){let e=this.playerState.actor.getMidpoint();if(e.x>d){let i={left:{}},o=["high","medium","low"].find(r=>e.y>=u[r][0]&&e.y<u[r][1]);o&&(i.left[o]=!0),t(this.x+1,this.y,i)}else if(e.x<0){let i={right:{}},o=["high","medium","low"].find(r=>e.y>=u[r][0]&&e.y<u[r][1]);o&&(i.right[o]=!0),t(this.x-1,this.y,i)}else if(e.y>m){let i={top:{}},o=["left","center","right"].find(r=>e.x>=u[r][0]&&e.x<u[r][1]);o&&(i.top[o]=!0),t(this.x,this.y+1,i)}else if(e.y<0){let i={bottom:{}},o=["left","center","right"].find(r=>e.x>=u[r][0]&&e.x<u[r][1]);o&&(i.bottom[o]=!0),t(this.x,this.y-1,i)}}onAllEnemiesCleared(){this.solids=this.solids.filter(t=>!t.blocker)}setExternalMatchingDoorways(t){let e={};for(let i in t){let o=i;for(let r in t[o]){let n=r;if(o==="left"||o==="right"){let h=r;t[o][h]===!1&&this.doors[o][h]===!0&&(e[o]=e[o]??{},e[o][h]=!0)}else{let h=r;t[o][h]===!1&&this.doors[o][h]===!0&&(e[o]=e[o]??{},e[o][h]=!0)}}}this.solids.push(...Kt(e).map(i=>(i.color="yellow",i)))}drawForMap(t){t.fillStyle=this.color;for(let e of this.solids)e.blocker||t.fillRect(e.x,e.y,e.width,e.height)}addParticle(t){this.particles.push(t)}};var me=200,B=120,Nt=500/1e3,Rt=A("./img/theghost.png"),pe={x:100,y:100,width:d-200,height:m-200},Wt={x:-100,y:-100,width:d+200,height:m+200},ot=class{hp;alive;isNonPhysical;facing;x;y;xVelocity=0;yVelocity=0;collider;hurtVisualiser;particleCooldown;strategy;isStrategyComplete;distFromStart;distFromTarget;constructor(t,e){this.hp=20,this.alive=!0,this.isNonPhysical=!1,this.facing="left",this.x=t,this.y=e,this.collider={x:this.x-B/2,y:this.y-B/2,width:B,height:B},this.hurtVisualiser=v(1,250),this.particleCooldown=v(1,40),this.strategy="initialWait",this.isStrategyComplete=!1,this.distFromStart=()=>0,this.distFromTarget=()=>0}update(t,e,i){switch(this.hurtVisualiser.down(t),this.particleCooldown.down(t),this.strategy){case"initialWait":k(pe,i.x,i.y)&&this.initFlee(i);return;case"flee":let o=.8+Math.min(1.2,this.distFromStart()/600);this.collider.x+=this.xVelocity*t*o,this.collider.y+=this.yVelocity*t*o,f(Wt,this.collider)||this.initCharge(i),this.addParticle(e);return;case"charge":let r=.8+Math.min(1.2,this.distFromTarget()/600);this.collider.x+=this.xVelocity*t*r,this.collider.y+=this.yVelocity*t*r,this.distFromTarget()<=10&&this.initFlee(i),this.addParticle(e);return}}addParticle(t){if(this.particleCooldown.check()<=0){let e=_t(this.collider),i=4;t.addParticle(new L(e.x-i/2,e.y-i/2,4,4,"white",this.xVelocity*.1,this.yVelocity*.1,360,!0)),this.particleCooldown.up(1)}}initFlee(t){this.strategy="flee";let e=G(this.collider),i={x:t.x-e.x,y:t.y-e.y},o=yt(i,Nt);this.xVelocity=o.x,this.yVelocity=o.y,this.distFromStart=()=>gt(G(this.collider),e)}initCharge(t){this.strategy="charge";let e=vt(Wt);this.collider.x=e.x-B/2,this.collider.y=e.y-B/2;let i=t.x,o=t.y,r={x:i-e.x,y:o-e.y},n=yt(r,Nt);this.xVelocity=n.x,this.yVelocity=n.y,this.distFromTarget=()=>{let h=G(this.collider);return gt(h,{x:i,y:o})}}draw(t){this.hurtVisualiser.check()>0&&(t.filter="brightness(10000%) saturate(0%)");let e=Math.round(this.collider.x),i=Math.round(this.collider.y),o=(me-B)/2;t.drawImage(Rt,0,0,Rt.width,Rt.height,e-o,i-o,this.collider.width+2*o,this.collider.height+2*o),t.filter="none",!1}applyDamage(t){this.hp-=1,this.hurtVisualiser.up(1),this.hp<0&&(this.alive=!1)}intersects(t){if(f(t,this.collider))return this.collider}};var st=class extends R{getDoorwayChance(){return 0}static getDoorArrangement(){return{left:{high:!0,medium:!1,low:!1},right:{high:!0,medium:!1,low:!1},bottom:{left:!1,center:!1,right:!1},top:{left:!1,center:!1,right:!1}}}static isValidAt(){return!0}configureRoomContent(){let{solids:t,blockers:e}=M(this.doors);this.solids=t.concat(e).concat(...[240,390,540].map(i=>new c(40,i,d-80,10,{isDroppable:!0}))),this.enemies=[new ot(d/2,m/2)]}};var rt=class extends R{getDoorwayChance(){return 0}static getDoorArrangement(){return{left:{high:!1,medium:!1,low:!1},right:{high:!1,medium:!1,low:!1},bottom:{left:!0,center:!1,right:!0},top:{left:!0,center:!1,right:!0}}}static isValidAt(t,e){return e>=2}configureRoomContent(){let{blockers:t}=M(this.doors);this.solids=t.concat(new c(0,0,80,m),new c(d-80,0,80,m),new c(280,0,720,260),new c(280,460,720,260),new c(80,m-40,200,10,{isDroppable:!0}),new c(120,570,120,10,{isDroppable:!0}),new c(80,460,200,10,{isDroppable:!0}),new c(80,120,200,10,{isDroppable:!0}),new c(80,250,200,10,{isDroppable:!0}),new c(80,355,100,10,{isDroppable:!0}),new c(1e3,m-40,200,10,{isDroppable:!0}),new c(1040,570,120,10,{isDroppable:!0}),new c(1e3,460,200,10,{isDroppable:!0}),new c(1e3,120,200,10,{isDroppable:!0}),new c(1e3,250,200,10,{isDroppable:!0}),new c(1100,355,100,10,{isDroppable:!0}))}};var nt=class extends R{getDoorwayChance(){return .1}static getDoorArrangement(){return{left:{},right:{high:!1,medium:!1,low:!0},bottom:{},top:{left:!0,center:!1,right:!1}}}static isValidAt(t,e){return e>=2}configureRoomContent(){let{solids:t,blockers:e}=M(this.doors);this.solids=t.concat(e).concat(new c(380,0,d-380,450),new c(120,140,120,10,{isDroppable:!0}),new c(40,240,340,10,{isDroppable:!0}),new c(this.doors?.left?.center?160:40,340,this.doors.left.center?220:340,10,{isDroppable:!0}),new c(40,440,340,10,{isDroppable:!0}),new c(40,this.doors.left.low?550:540,240,10,{isDroppable:!0}))}};var Ut=340,St=76,Xt=60,Jt=80,ht=2.5/1e3,Dt=A("./img/spitboss-head.png"),Ct=A("./img/spitboss-base.png"),Et=A("./img/spitboss-spit.png"),at=class{hp;alive;isNonPhysical;x;y;baseBox;headBox;hurtVisualiser;fireCooldown;constructor(t,e){this.hp=50,this.alive=!0,this.isNonPhysical=!1,this.x=t,this.y=e,this.baseBox={x:this.x-Ut/2,y:this.y-St,width:Ut,height:St},this.headBox={x:this.x-Xt/2,y:Math.round(this.y-Jt-.75*St),width:Xt,height:Jt},this.hurtVisualiser=v(1,250),this.fireCooldown=v(1,1200)}draw(t){this.hurtVisualiser.check()>0&&(t.filter="brightness(1000%) saturate(0%)");let e=8,i=8;t.drawImage(Ct,0,0,Ct.width,Ct.height,this.baseBox.x-e,this.baseBox.y-i,this.baseBox.width+2*e,this.baseBox.height+i);let o=4;t.drawImage(Dt,0,0,Dt.width,Dt.height,this.headBox.x-o,this.headBox.y-o,this.headBox.width+2*o,this.headBox.height+2*o),t.filter="none",!1}update(t,e,i){if(this.hurtVisualiser.down(t),this.fireCooldown.down(t),this.fireCooldown.check()===0){let o=this.createProjectile(e,i);o&&o.length>0&&(this.fireCooldown.up(1),e.enemies.push(...o))}}createProjectile(t,e){let i={x:this.x-5,width:10,y:0,height:this.y},r=t.solids.filter(a=>a.isCollidable&&!a.isDroppable&&f(a,i)).reduce((a,x)=>Math.max(a,x.y+x.height),0),n=this.y-100,h=n-r-X,l=-Math.sqrt(2*ht*h);if(e.y<=h)return;let p=b(.8,1)*l,g=p*p-2*ht*(n-e.y);if(g<=0)return;let D=(-p+Math.sqrt(g))/ht,O=(e.x-this.x)/D,C=Y(1,4);return new Array(C).fill(0).map(()=>new At(this.x,n,O+b(-.1,.1),p+b(-.01,.1),this))}applyDamage(t){t===this.headBox?(this.hp-=3,this.hurtVisualiser.up(1)):t===this.baseBox&&(this.hp-=.2,this.hurtVisualiser.up(.2)),this.hp<0&&(this.alive=!1)}intersects(t){if(f(t,this.headBox))return this.headBox;if(f(t,this.baseBox))return this.baseBox}},X=14,At=class{actor;xVelocity;yVelocity;parent;alive;struck;hitVisualiser;constructor(t,e,i,o,r){this.actor=new P(t-X,e-X,X*2,X*2),this.xVelocity=i,this.yVelocity=o,this.parent=r,this.alive=!0,this.struck=!1,this.hitVisualiser=v(1,150)}draw(t){t.drawImage(Et,0,0,Et.width,Et.height,this.actor.x-2,this.actor.y-2,this.actor.width+4,this.actor.height+4)}addParticle(t,e,i){t.addParticle(new L(e.x-3,e.y-3,6,6,Math.random()>.5?"#674cd3":"#9e5eff",i.x,i.y,b(120,200),!0))}update(t,e,i){this.hitVisualiser.down(t);let o=r=>n=>{this.alive=!1;let h=r==="x"?{x:this.xVelocity>0?n.x:n.x+n.width,y:this.actor.y+this.actor.height/2}:{x:this.actor.x+this.actor.width/2,y:this.yVelocity>0?n.y:n.y+n.height};for(let l=0;l<12;l++){let p=r==="x"?{x:-this.xVelocity*b(.4,.6),y:b(-.2,.2)}:{x:b(-.2,.2),y:-this.yVelocity*b(.2,.3)};this.addParticle(e,h,p)}};if(this.yVelocity+=ht*t,this.actor.moveX(this.xVelocity*t,o("x"),e.solids),this.actor.moveY(this.yVelocity*t,o("y"),e.solids),this.struck&&this.parent.alive){let r=this.parent.intersects(this.actor);if(r){this.parent.applyDamage(r);let n=Vt(G(this.actor),It(r,16));console.log(this.xVelocity,this.yVelocity);for(let h=0;h<12;h++){let l={x:-this.xVelocity*b(.4,.6)+b(-.2,.2),y:-this.yVelocity*b(.2,.3)+b(-.2,.2)};this.addParticle(e,n,l)}this.alive=!1}}}applyDamage(t,e){this.hitVisualiser.up(1),this.xVelocity=e?.x??0,this.yVelocity=e?.y??0,this.struck=!0}intersects(t){if(f(t,this.actor))return this.actor}};var lt=class extends R{getDoorwayChance(){return .1}static getDoorArrangement(){return{left:{high:!1,medium:!1,low:!1},right:{high:!1,medium:!1,low:!1},bottom:{left:!1,center:!1,right:!1},top:{left:!1,center:!0,right:!1}}}static isValidAt(t,e){return!0}configureRoomContent(){let{solids:t,blockers:e}=M(this.doors);this.solids=t.concat(e).concat(new c(320,160,920,40),new c(840,0,440,200),new c(0,0,80,m),new c(d-80,0,80,m),new c(0,m-80,d,80),new c(80,160,240,10,{isDroppable:!0})),this.enemies=[new at(780,m-80)]}onAllEnemiesCleared(){super.onAllEnemiesCleared(),this.solids=this.solids.concat(...[320,480].map(t=>new c(80,t,240,10,{isDroppable:!0})))}};function ue(s){return!!s}var ct=class extends R{getDoorwayChance(){return 0}static getDoorArrangement(){return{left:{high:!0,medium:!1,low:!1},right:{high:!0,medium:!1,low:!1},bottom:{left:!1,center:!0,right:!1},top:{}}}configureRoomContent(){let{solids:t,blockers:e}=M(this.doors);this.solids=t.concat(e).concat(new c(0,240,440,m-240),new c(840,240,d-840,m-240),new c(440,240,400,10,{isDroppable:!0}),new c(440,380,400,10,{isDroppable:!0}),new c(440,520,400,10,{isDroppable:!0})).concat(...[this.doors.top.left?new c(120,120,120,10,{isDroppable:!0}):void 0,this.doors.top.center?new c(580,120,120,10,{isDroppable:!0}):void 0,this.doors.top.right?new c(1040,120,120,10,{isDroppable:!0}):void 0].filter(ue)),this.enemies=[new U(d/4,176),new U(d*3/4,176)]}};var K=128,N=72,zt=9,jt=6,qt=1/10,J=2,Zt=4,dt=class{lastRoomIndex;map;x;y;currentIndex;minX;minY;canvas;ctx;constructor(){this.lastRoomIndex={x:0,y:0},this.map={},this.x=0,this.y=0,this.currentIndex=this.index(0,0),this.minX=0,this.minY=0;let t=new R(0,0,1,1);this.map[this.index(0,0)]=t;let e=Math.max(zt),i=Math.max(jt);this.canvas=new OffscreenCanvas(e*K,i*N);let o=this.canvas.getContext("2d");if(!o)throw Error("Could not construct canvas");this.ctx=o,this.redrawWorldMap()}createNewCanvas(t,e,i,o){let r=Math.max(zt,e-t+1+Zt),n=Math.max(jt,o-i+1+Zt);this.canvas=new OffscreenCanvas(r*K,n*N);let h=this.canvas.getContext("2d");if(!h)throw Error("Could not construct canvas");this.ctx=h}getNeighboringDoors(t,e){return{right:{...this.map[this.index(t+1,e)]?.doors?.left},left:{...this.map[this.index(t-1,e)]?.doors?.right},top:{...this.map[this.index(t,e-1)]?.doors?.bottom},bottom:{...this.map[this.index(t,e+1)]?.doors?.top}}}generateRoomChoices(t,e,i={}){let o=()=>`hsl(${Y(0,360)}, 60%, 60%)`,r=()=>({left:{...i.left??{}},right:{...i.right??{}},top:{...i.top??{}},bottom:{...i.bottom??{}}}),n=[st,rt,nt,ct,lt],h=r(),l=n.filter(g=>g.isValidAt(t,e)&&g.areDoorsOk(h));l.push(R,R,R);let p=[];for(let g=0;g<3;g++){let D=l.shift();if(!D)throw new Error("Could not find enough rooms");p.push(new D(t,e,1,1,o(),r()))}return p}redrawWorldMap(){let t=0,e=0;for(let i of Object.values(this.map))this.minX=Math.min(this.minX,i.x),t=Math.max(t,i.x),this.minY=Math.min(this.minY,i.y),e=Math.max(e,i.y);(t-this.minX+1>this.canvas.width/K||e-this.minY+1>this.canvas.height/N)&&this.createNewCanvas(this.minX,t,this.minY,e),this.ctx.fillStyle="black",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);for(let i of Object.values(this.map))this.ctx.save(),this.ctx.translate((i.x-this.minX)*K,(i.y-this.minY)*N),this.ctx.scale(qt,qt),i.drawForMap(this.ctx),this.ctx.restore()}drawMapToScreen(t,e,i,o,r){let n=Math.min(o,this.canvas.width),h=Math.min(r,this.canvas.height),l=(-this.minX+this.x+1/2)*K-o/2;t.drawImage(this.canvas,l,0,n,h,e,i,n,h),t.strokeStyle="white",t.lineWidth=J,t.strokeRect(-l+(this.x-this.minX+1/2)*K-J,i+this.y*N-J,K+J*2,N+J*2)}index(t,e){return`${t},${e}`}getCurrentRoom(){return this.map[this.currentIndex]}getPreviousRoom(){return this.map[this.index(this.lastRoomIndex.x,this.lastRoomIndex.y)]}hasRoom(t,e){return this.index(t,e)in this.map}enterRoom(t,e){this.lastRoomIndex={x:this.x,y:this.y},this.x=t,this.y=e,this.currentIndex=this.index(t,e),this.redrawWorldMap()}addRoom(t){if(this.map[this.currentIndex])throw new Error("Adding room where we already have one!");this.map[this.currentIndex]=t,this.map[this.index(this.x-1,this.y)]?.setExternalMatchingDoorways?.({right:t.doors.left}),this.map[this.index(this.x+1,this.y)]?.setExternalMatchingDoorways?.({left:t.doors.right}),this.map[this.index(this.x,this.y-1)]?.setExternalMatchingDoorways?.({bottom:t.doors.top}),this.map[this.index(this.x,this.y+1)]?.setExternalMatchingDoorways?.({top:t.doors.bottom}),t.setExternalMatchingDoorways({left:this.map[this.index(this.x-1,this.y)]?.doors?.right,right:this.map[this.index(this.x+1,this.y)]?.doors?.left,top:this.map[this.index(this.x,this.y-1)]?.doors?.bottom,bottom:this.map[this.index(this.x,this.y+1)]?.doors?.top}),this.redrawWorldMap()}};var mt=2,fe="Tab",T=64,pt=4,ut=class{worldMap;lastFrameTime;unprocessedTime;pausedFor;choosing;choices;tabLatch;mouseOverChoiceIndex;firstTickInNewRoom;constructor(){this.worldMap=new dt,this.lastFrameTime=performance.now(),this.unprocessedTime=0,this.pausedFor=void 0,this.choosing=!0,this.choices=[],this.tabLatch=Mt(!1),this.mouseOverChoiceIndex=-1,this.firstTickInNewRoom=!1}update(t,e,i,o){if(this.tabLatch(!!o[fe],{onLock:()=>{this.pausedFor==="Tab"?(this.lastFrameTime=performance.now(),this.pausedFor=void 0):this.pausedFor||(this.pausedFor="Tab")}}),this.pausedFor==="choices"){this.choices.length===0&&(this.choices=this.worldMap.generateRoomChoices(this.worldMap.x,this.worldMap.y)),this.draw(t,e,i,0),this.drawMap(t,e),this.drawOptions(t,e,i);return}else if(this.pausedFor==="Tab"){this.draw(t,e,i,0),this.drawMap(t,e);return}let r=performance.now(),n=this.firstTickInNewRoom?0:Math.min(r-this.lastFrameTime,250);for(this.lastFrameTime=r,this.firstTickInNewRoom=!1,this.unprocessedTime+=n;this.unprocessedTime>=mt&&!this.pausedFor;)this.simulateFrame(i,o),this.unprocessedTime-=mt;this.pausedFor&&(this.unprocessedTime=0);let h=this.unprocessedTime/mt;this.draw(t,e,i,h)}drawMap(t,e){t.fillStyle="#00000099",t.fillRect(0,0,e.width,e.height),t.fillStyle="white",t.fillRect(T-pt,T-pt,e.height-(T-pt)*2,e.height-(T-pt)*2),t.fillStyle="black",t.fillRect(T,T,e.height-T*2,e.height-T*2),this.worldMap.drawMapToScreen(t,T,T,e.height-T*2,e.height-T*2)}click(t,e){let i=this.pausedFor==="choices"&&this.choices.length>0,o=this.mouseOverChoiceIndex>=0&&this.mouseOverChoiceIndex<this.choices.length;if(i&&o){let r=this.choices[this.mouseOverChoiceIndex];this.worldMap.addRoom(r);let n=this.worldMap.getPreviousRoom();this.transferPlayerPosition(n,r),this.unprocessedTime=0,this.firstTickInNewRoom=!0,this.pausedFor=void 0,this.choices=[]}}transferPlayerPosition(t,e){e.playerState.xVelocity=t.playerState.xVelocity,e.playerState.yVelocity=Math.min(t.playerState.yVelocity,.1);let i=t.playerState.actor.x+t.x*d,o=t.playerState.actor.y+t.y*m;e.playerState.actor.x=i-e.x*d,e.playerState.actor.y=o-e.y*m,e.y>=t.y+t.height?e.playerState.actor.y=Math.min(e.playerState.actor.y,1):e.y+e.height<=t.y&&(e.playerState.yVelocity=Math.min(-1.1,e.playerState.yVelocity)),e.playerState.facing=t.playerState.facing}simulateFrame(t,e){this.worldMap.getCurrentRoom().update(t,e,mt,this.onRoomChange.bind(this))}onRoomChange(t,e,i){this.worldMap.hasRoom(t,e)?(this.worldMap.enterRoom(t,e),this.transferPlayerPosition(this.worldMap.getPreviousRoom(),this.worldMap.getCurrentRoom())):(this.pausedFor="choices",this.worldMap.enterRoom(t,e),this.choices=this.worldMap.generateRoomChoices(this.worldMap.x,this.worldMap.y,i))}draw(t,e,i,o){let r=this.worldMap.getCurrentRoom();r&&r.draw(t,e,i,o)}drawOptions(t,e,i){this.mouseOverChoiceIndex=-1;for(let o=0;o<this.choices.length;o++){let r=this.choices[o],n=e.height,h=e.width,l=(n+h)/2,p=e.height/this.choices.length,g=p*o,D=g+p;t.save(),t.translate(l,(g+D)/2);let O=i&&k({x:n,y:g,width:h-n,height:p},i.x,i.y),C=(h-n)/d*.5;t.scale(C,C),O&&(this.mouseOverChoiceIndex=o,t.scale(1.1,1.1)),t.translate(-d/2,-m/2),r.drawForMap(t),t.restore()}}};function ye(){let s=document.getElementById("canvas");if(!s){console.error("Could not find canvas");return}let t=s.getContext("2d");if(!t)throw console.error(""),Error("Could not set up canvas rendering context");t.imageSmoothingEnabled=!1;let e=new ut,i;s.addEventListener("mousemove",n=>{let h=s.getBoundingClientRect(),l=n.clientX-h.left,p=n.clientY-h.top;i={x:l,y:p}}),s.addEventListener("mouseleave",()=>{i=void 0}),s.addEventListener("click",n=>{let h=s.getBoundingClientRect(),l=n.clientX-h.left,p=n.clientY-h.top;i={x:l,y:p},e.click(s,i)});let o={};window.addEventListener("keydown",n=>{o[n.key]=!0,(n.key==="Tab"||n.key===" ")&&n.preventDefault()}),window.addEventListener("keyup",n=>{delete o[n.key]}),window.addEventListener("blur",()=>{o={}});function r(){e.update(t,s,i,o),requestAnimationFrame(r)}r()}document.addEventListener("DOMContentLoaded",()=>{ye()});})();
//# sourceMappingURL=index.js.map
