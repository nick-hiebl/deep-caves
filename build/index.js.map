{
  "version": 3,
  "sources": ["../js/core/latch.ts", "../js/core/math.ts", "../js/core/solid.ts", "../js/core/actor.ts", "../js/core/sprite.ts", "../js/room/particle.ts", "../js/player/attack.ts", "../js/player/inputController.ts", "../js/player/jumpController.ts", "../js/player/playerState.ts", "../js/room/enemy/enemy.ts", "../js/room/enemy/walker.ts", "../js/room/movingPlatform.ts", "../js/room/room-utils.ts", "../js/room/room.ts", "../js/room/enemy/bosses/ghost-boss.ts", "../js/room/layouts/ghost_room.ts", "../js/room/layouts/h_room.ts", "../js/room/layouts/l_room.ts", "../js/room/enemy/bosses/spit-boss.ts", "../js/room/layouts/pit_room.ts", "../js/room/layouts/t_room.ts", "../js/worldMap.ts", "../js/caveWorld.ts", "../js/main.ts"],
  "sourcesContent": ["export type BooleanLatch = (newState: boolean, handlers: { onLock?: () => void; onRelease?: () => void }) => void;\n\nexport const latch = (initialState: boolean): BooleanLatch => {\n    let state = initialState;\n\n    return (newState, { onLock, onRelease }) => {\n        if (newState === state) {\n            return;\n        }\n\n        state = newState;\n        if (newState) {\n            if (onLock) onLock();\n        } else {\n            if (onRelease) onRelease();\n        }\n    };\n};\n\nexport type IncDecLatch = {\n    up: (by?: number) => void;\n    down: (by?: number) => void;\n    check: () => number;\n};\n\nexport const incDecLatch = (stepsUp: number, stepsDown: number): IncDecLatch => {\n    let state = 0;\n\n    return {\n        up(by = 1) {\n            state = Math.min(1, state + by / stepsUp);\n        },\n        down(by = 1) {\n            state = Math.max(0, state - by / stepsDown);\n        },\n        check() {\n            return state;\n        },\n    };\n};\n", "export function lerp(a: number, b: number, t: number) {\n    return (1 - t) * a + t * b;\n}\n\nexport function randint(lo: number, hi: number) {\n    return Math.floor((hi - lo) * Math.random());\n}\n\nexport function randfloat(lo: number, hi: number) {\n    return lo + Math.random() * (hi - lo);\n}\n\nexport type Vector = {\n    x: number;\n    y: number;\n};\n\nexport type Rect = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n};\n\nexport function overlaps(a: Rect, b: Rect) {\n    if (a.x >= b.x + b.width || b.x >= a.x + a.width) {\n        return false;\n    }\n\n    if (a.y >= b.y + b.height || b.y >= a.y + a.height) {\n        return false;\n    }\n\n    return true;\n}\n\nexport function isPointInside(rect: Rect, x: number, y: number) {\n    return rect.x <= x && x < rect.x + rect.width && rect.y <= y && y < rect.y + rect.height;\n}\n\nexport function square(x: number) {\n    return x * x;\n}\n\nexport function approach(target: number, current: number, step: number) {\n    if (target > current) {\n        return Math.min(target, current + step);\n    } else if (target < current) {\n        return Math.max(target, current - step);\n    } else {\n        return target;\n    }\n}\n\nexport function clamp(x: number, lo: number, hi: number) {\n    return Math.max(lo, Math.min(x, hi));\n}\n\nexport function clampPointWithin(vector: Vector, rect: Rect) {\n    return {\n        x: clamp(vector.x, rect.x, rect.x + rect.width),\n        y: clamp(vector.y, rect.y, rect.y + rect.height),\n    };\n}\n\nexport function insetRect(rect: Rect, insetBy: number) {\n    return {\n        x: rect.x + insetBy,\n        y: rect.y + insetBy,\n        width: rect.width - 2 * insetBy,\n        height: rect.height - 2 * insetBy,\n    };\n}\n\nexport function rectMidpoint(rect: Rect) {\n    return {\n        x: rect.x + rect.width / 2,\n        y: rect.y + rect.height / 2,\n    };\n}\n\nexport function normalize(vector: Vector, radius: number) {\n    const magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n\n    return {\n        x: vector.x * radius / magnitude,\n        y: vector.y * radius / magnitude,\n    };\n}\n\nexport function distance(p1: Vector, p2: Vector) {\n    return Math.sqrt(square(p1.x - p2.x) + square(p1.y - p2.y));\n}\n\nexport function randomPerimeterPoint(rect: Rect) {\n    const halfPerimeter = rect.width + rect.height;\n    const pos = randfloat(0, halfPerimeter);\n\n    if (pos < rect.width) {\n        return {\n            x: rect.x + pos,\n            y: randint(0, 2) ? rect.y : rect.y + rect.height,\n        };\n    } else {\n        return {\n            x: randint(0, 2) ? rect.x : rect.x + rect.width,\n            y: rect.y + (pos - rect.width),\n        };\n    }\n}\n\nexport function randomPointInRect(rect: Rect) {\n    return {\n        x: rect.x + randfloat(0, rect.width),\n        y: rect.y + randfloat(0, rect.height),\n    };\n}\n", "import type { Actor } from './actor';\nimport { overlaps } from './math';\n\nexport type SolidConfig = {\n    isDroppable?: boolean;\n};\n\nexport class Solid {\n    x: number;\n    y: number;\n    height: number;\n    width: number;\n\n    isCollidable: boolean;\n    isDroppable: boolean;\n    color: string | undefined;\n\n    private xRemainder: number;\n    private yRemainder: number;\n\n    blocker: boolean;\n\n    constructor(x: number, y: number, width: number, height: number, config: SolidConfig = {}) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        this.isCollidable = true;\n        this.isDroppable = config.isDroppable ?? false;\n        this.blocker = false;\n\n        this.xRemainder = 0;\n        this.yRemainder = 0;\n    }\n\n    move(x: number, y: number, actors: Actor[], solids: Solid[]) {\n        this.xRemainder += x;\n        this.yRemainder += y;\n\n        let moveX = Math.round(this.xRemainder);\n        let moveY = Math.round(this.yRemainder);\n\n        if (moveX !== 0 || moveY !== 0) {\n            const riding = actors.filter(actor => actor.isRiding(this));\n\n            this.isCollidable = false;\n\n            if (moveX !== 0) {\n                this.xRemainder -= moveX;\n                this.x += moveX;\n\n                if (moveX > 0) {\n                    for (const actor of actors) {\n                        if (overlaps(this, actor)) {\n                            /** Push right */\n                            actor.moveX(this.x + this.width - actor.x, actor.squish, solids);\n                        } else if (riding.some(a => a === actor)) {\n                            /** Carry right */\n                            actor.moveX(moveX, () => {}, solids);\n                        }\n                    }\n                } else if (moveX < 0) {\n                    for (const actor of actors) {\n                        if (overlaps(this, actor)) {\n                            /** Push left */\n                            actor.moveX(this.x - (actor.x + actor.width), actor.squish, solids);\n                        } else if (riding.some(a => a === actor)) {\n                            /** Carry left */\n                            actor.moveX(moveX, () => {}, solids);\n                        }\n                    }\n                }\n            }\n\n            this.isCollidable = true;\n        }\n    }\n}\n", "import { isPointInside, overlaps } from './math';\nimport { Solid } from './solid';\n\nconst STEP_SIZE = 4;\n\nexport class Actor {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n\n    private xRemainder: number;\n    private yRemainder: number;\n\n    isDropping: boolean;\n    droppingSet: Set<any>;\n\n    constructor(x: number, y: number, width: number, height: number) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        this.xRemainder = 0;\n        this.yRemainder = 0;\n\n        this.isDropping = false;\n        this.droppingSet = new Set();\n    }\n\n    setDropping(isDropping: boolean | undefined) {\n        this.isDropping = !!isDropping;\n\n        this.droppingSet = new Set(Array.from(this.droppingSet).filter(solid => overlaps(this, solid)));\n    }\n\n    moveX(amount: number, onCollide: (solid: Solid) => void, solids: Solid[]) {\n        this.xRemainder += amount;\n        let move = Math.round(this.xRemainder);\n\n        if (move !== 0) {\n            this.xRemainder -= move;\n            const sign = move > 0 ? 1 : -1;\n\n            while (move !== 0) {\n                this.x += sign;\n                move -= sign;\n\n                /** Backtrack one step on collision and return */\n                const { collidingSolid, droppingThroughSolids } = this.collideAt(solids);\n\n                /** If entering a droppable solid horizontally, you fall through it */\n                droppingThroughSolids.forEach(solid => {\n                    this.droppingSet.add(solid);\n                });\n\n                if (collidingSolid) {\n                    this.x -= sign;\n                    onCollide(collidingSolid);\n                    break;\n                }\n            }\n        }\n    }\n\n    moveY(amount: number, onCollide: (solid: Solid) => void, solids: Solid[]) {\n        this.yRemainder += amount;\n        let move = Math.round(this.yRemainder);\n\n        if (move !== 0) {\n            this.yRemainder -= move;\n            const sign = move > 0 ? 1 : -1;\n\n            /** Process leftovers if any */\n            while (move !== 0) {\n                this.y += sign;\n                move -= sign;\n\n                /** Backtrack one step on collision and return */\n                let { collidingSolid, droppingThroughSolids } = this.collideAt(solids);\n\n                /** If moving up or dropping then just mark solids we are dropping through */\n                if ((sign < 0 || this.isDropping) && droppingThroughSolids.length > 0) {\n                    droppingThroughSolids.forEach(solid => this.droppingSet.add(solid));\n                } else if (droppingThroughSolids.length > 0) {\n                    /** We are falling and not dropping through platforms */\n                    collidingSolid = droppingThroughSolids[0];\n                }\n\n                if (collidingSolid) {\n                    this.y -= sign;\n                    onCollide(collidingSolid);\n                    break;\n                }\n            }\n        }\n    }\n\n    isGrounded(solids: Solid[]) {\n        const groundingCollider = { x: this.x, y: this.y + this.height, width: this.width, height: 1 };\n\n        const groundingSolid = solids.find(solid => {\n            if (this.droppingSet.has(solid)) {\n                return false;\n            }\n\n            if (this.isDropping && solid.isDroppable) {\n                return false;\n            }\n\n            return overlaps(groundingCollider, solid);\n        });\n\n        return !!groundingSolid;\n    }\n\n    collideAt(solids: Solid[]) {\n        const droppingThroughSolids: Solid[] = [];\n\n        const collidingSolid = solids.find(solid => {\n            if (!solid.isCollidable) {\n                return false;\n            }\n\n            const overlapping = overlaps(this, solid);\n\n            if (!overlapping) {\n                return false;\n            }\n\n            if (solid.isDroppable) {\n                if (!this.droppingSet.has(solid)) {\n                    droppingThroughSolids.push(solid);\n                } else {\n                    // return true;\n                }\n                return false;\n            }\n\n            return true;\n        });\n\n        return { collidingSolid, droppingThroughSolids };\n    }\n\n    isRiding(solid: Solid) {\n        return isPointInside(solid, this.x, this.y + this.height)\n            || isPointInside(solid, this.x + this.width - 1, this.y + this.height);\n    }\n\n    squish() {\n        console.log('Squish');\n    }\n\n    getMidpoint() {\n        return {\n            x: this.x + this.width / 2,\n            y: this.y + this.height / 2,\n        };\n    }\n}\n", "export const Sprite = (src: string) => {\n    const sprite = new Image();\n    sprite.src = src;\n\n    return sprite;\n};\n", "import type { Rect } from '../core/math';\n\nconst GRAVITY = 2.5 / 1000;\n\nexport class Particle implements Rect {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n\n    color: string;\n    xVelocity: number;\n    yVelocity: number;\n\n    lifeLeft: number;\n    lifespan: number;\n\n    alive: boolean;\n    affectedByGravity: boolean;\n\n    constructor(x: number, y: number, width: number, height: number, color: string, vX: number, vY: number, lifespan: number, gravity = false) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.color = color;\n        this.xVelocity = vX;\n        this.yVelocity = vY;\n\n        this.lifeLeft = lifespan;\n        this.lifespan = lifespan;\n\n        this.alive = true;\n\n        this.affectedByGravity = gravity;\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        ctx.filter = `opacity(${Math.round(100 * this.lifeLeft / this.lifespan)}%)`;\n        ctx.fillStyle = this.color;\n        ctx.fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);\n        ctx.filter = 'none';\n    }\n\n    update(frameDuration: number) {\n        if (this.affectedByGravity) {\n            this.yVelocity += frameDuration * GRAVITY;\n        }\n\n        this.x += frameDuration * this.xVelocity;\n        this.y += frameDuration * this.yVelocity;\n\n        this.lifeLeft = Math.max(0, this.lifeLeft - frameDuration);\n\n        if (this.lifeLeft <= 0) {\n            this.alive = false;\n        }\n    }\n}\n", "import { DRAW_FRAME_MARKERS } from '../constants';\nimport { Sprite } from '../core/sprite';\nimport type { EnemyInterface } from '../room/enemy/interface';\n\nconst SWORD_SWOOSH = Sprite('./img/sword_slash.png');\n\nconst ATTACK_HEIGHT = 36;\nconst ATTACK_WIDTH = 56;\nconst ATTACK_SCALE = 2;\n\nconst KNOCKBACK_AMOUNT = 0.7;\n\nexport class Attack {\n    facing: 'left' | 'right';\n\n    box: { x: number; y: number; width: number; height: number };\n\n    interactedWith: Set<EnemyInterface>;\n\n    constructor(facing: 'left' | 'right') {\n        this.facing = facing;\n\n        this.box = {\n            width: ATTACK_WIDTH * ATTACK_SCALE,\n            height: ATTACK_HEIGHT * ATTACK_SCALE,\n            x: facing === 'left' ? -ATTACK_WIDTH * ATTACK_SCALE * 3 / 4 : -ATTACK_WIDTH * ATTACK_SCALE * 1 / 4,\n            y: -ATTACK_HEIGHT * ATTACK_SCALE / 2,\n        };\n\n        this.interactedWith = new Set();\n    }\n\n    prePlayerDraw(ctx: CanvasRenderingContext2D, relativePosition: { x: number; y: number }, attackTransparency: number) {\n        const attackSrcX = this.facing === 'left' ? 0 : ATTACK_WIDTH;\n        const attackDestX = relativePosition.x + this.box.x;\n        const attackDestY = relativePosition.y + this.box.y;\n\n        ctx.globalAlpha = attackTransparency;\n        ctx.drawImage(\n            SWORD_SWOOSH,\n            /** Src parameters */\n            attackSrcX,\n            0,\n            ATTACK_WIDTH,\n            ATTACK_HEIGHT / 2,\n            /** Destination parameters */\n            attackDestX,\n            attackDestY,\n            ATTACK_WIDTH * ATTACK_SCALE,\n            ATTACK_HEIGHT * ATTACK_SCALE / 2,\n        );\n        ctx.globalAlpha = 1;\n    }\n\n    postPlayerDraw(ctx: CanvasRenderingContext2D, relativePosition: { x: number; y: number }, attackTransparency: number) {\n        const attackSrcX = this.facing === 'left' ? 0 : ATTACK_WIDTH;\n        const attackDestX = relativePosition.x + this.box.x;\n        const attackDestY = relativePosition.y + this.box.y;\n\n        ctx.globalAlpha = attackTransparency;\n        ctx.drawImage(\n            SWORD_SWOOSH,\n            /** Src parameters */\n            attackSrcX,\n            ATTACK_HEIGHT / 2,\n            ATTACK_WIDTH,\n            ATTACK_HEIGHT / 2,\n            /** Destination parameters */\n            attackDestX,\n            attackDestY + ATTACK_HEIGHT * ATTACK_SCALE / 2,\n            ATTACK_WIDTH * ATTACK_SCALE,\n            ATTACK_HEIGHT * ATTACK_SCALE / 2,\n        );\n        ctx.globalAlpha = 1;\n\n        if (DRAW_FRAME_MARKERS) {\n            ctx.strokeStyle = 'pink';\n\n            ctx.strokeRect(relativePosition.x + this.box.x, relativePosition.y + this.box.y, this.box.width, this.box.height);\n        }\n    }\n\n    getBox(base: { x: number; y: number }) {\n        return {\n            x: base.x + this.box.x,\n            y: base.y + this.box.y,\n            width: this.box.width,\n            height: this.box.height,\n        };\n    }\n\n    interactWithEnemy(basePosition: { x: number; y: number }, enemy: EnemyInterface) {\n        if (this.interactedWith.has(enemy)) {\n            return;\n        }\n        const box = this.getBox(basePosition);\n\n        const hitBox = enemy.intersects(box);\n\n        if (hitBox) {\n            this.interactedWith.add(enemy);\n            enemy.applyDamage(hitBox, { x: this.facing === 'left' ? -KNOCKBACK_AMOUNT : KNOCKBACK_AMOUNT });\n        }\n    }\n}\n", "export class BufferedThrottledInputController {\n    preBufferDuration: number;\n    coolDown: number;\n    activeDuration: number;\n\n    isPressed: boolean;\n    timeSinceUnusedPress: number | undefined;\n    isActive: boolean;\n    timeSinceActivation: number;\n\n    constructor(preBufferDuration: number, coolDown: number, activeDuration: number) {\n        /** Saved config */\n        this.preBufferDuration = preBufferDuration;\n        this.coolDown = coolDown;\n        this.activeDuration = activeDuration;\n\n        /** State variables */\n        this.isPressed = false;\n        this.timeSinceUnusedPress = undefined;\n        this.isActive = false;\n        this.timeSinceActivation = Math.max(coolDown, activeDuration);\n    }\n\n    update(frameDuration: number, isPressed: boolean | undefined, onActivation: () => void) {\n        if (!this.isPressed) {\n            if (isPressed) {\n                this.timeSinceUnusedPress = 0;\n            } else {\n                this.timeSinceUnusedPress = undefined;\n            }\n        } else {\n            if (isPressed) {\n                this.timeSinceUnusedPress = (this.timeSinceUnusedPress ?? 0) + frameDuration;\n            }\n        }\n\n        this.isPressed = !!isPressed;\n\n        if (this.timeSinceActivation < this.activeDuration || this.timeSinceActivation < this.coolDown) {\n            this.timeSinceActivation += frameDuration;\n        }\n\n        if (this.timeSinceActivation >= this.activeDuration) {\n            this.isActive = false;\n        }\n\n        const isPressReady = this.timeSinceUnusedPress !== undefined && this.timeSinceUnusedPress < this.preBufferDuration;\n\n        if (!this.isActive && isPressReady && this.timeSinceActivation >= this.coolDown) {\n            this.isActive = true;\n            this.timeSinceActivation = 0;\n            this.timeSinceUnusedPress = undefined;\n            onActivation();\n        }\n    }\n\n    fractionThroughCooldown() {\n        if (!this.isActive) {\n            return undefined;\n        }\n\n        return this.timeSinceActivation / this.activeDuration;\n    }\n}", "const GRAVITY = 2.5 / 1000;\nconst HIGH_GRAVITY = 6 / 1000;\n\nconst Y_VELOCITY_CUTOFF = -0.5;\n\n/** Physics utils */\nconst COYOTE_DURATION = 100;\n\nexport const JUMP_KEY = ' ';\n\nexport class JumpController {\n    isGrounded: boolean;\n    coyoteTime: number;\n    timeSinceJumpPress: number;\n    isJumpKeyDown: boolean;\n    stillHoldingJump: boolean;\n\n    constructor() {\n        this.isGrounded = false;\n        this.coyoteTime = 0;\n        this.timeSinceJumpPress = COYOTE_DURATION * 2;\n        this.isJumpKeyDown = false;\n        this.stillHoldingJump = false;\n    }\n\n    update(keyboardState: Record<string, boolean>, frameDuration: number, yVelocity: number) {\n        this.coyoteTime -= frameDuration;\n\n        if (keyboardState[JUMP_KEY]) {\n            if (this.isJumpKeyDown) {\n                this.timeSinceJumpPress += frameDuration;\n            } else {\n                this.isJumpKeyDown = true;\n                this.timeSinceJumpPress = 0;\n            }\n        } else {\n            this.stillHoldingJump = false;\n            this.isJumpKeyDown = false;\n            this.timeSinceJumpPress = COYOTE_DURATION * 2;\n        }\n\n        const isJumpDesired = this.isJumpKeyDown && this.timeSinceJumpPress < COYOTE_DURATION;\n\n        const isJumping = isJumpDesired && (this.isGrounded || this.coyoteTime > 0);\n\n        if (isJumping) {\n            this.stillHoldingJump = true;\n            this.timeSinceJumpPress = COYOTE_DURATION * 2;\n            this.coyoteTime = 0;\n        }\n\n        return { isJumping, yAcceleration: this.getGravity(yVelocity) };\n    }\n\n    getGravity(yVelocity: number) {\n        if (yVelocity > Y_VELOCITY_CUTOFF || !this.stillHoldingJump) {\n            return HIGH_GRAVITY;\n        }\n\n        return GRAVITY;\n    }\n\n    groundedCheck(nowGrounded: boolean, nowJumping: boolean) {\n        if (this.isGrounded && !nowGrounded && !nowJumping) {\n            this.coyoteTime = COYOTE_DURATION;\n        } else if (nowGrounded) {\n            this.coyoteTime = 0;\n        }\n\n        this.isGrounded = nowGrounded;\n    }\n}\n", "import { DRAW_FRAME_MARKERS } from '../constants';\nimport { Actor } from '../core/actor';\nimport { approach, lerp, randfloat, square, type Vector } from '../core/math';\nimport { Sprite } from '../core/sprite';\nimport { Particle } from '../room/particle';\nimport type { Room } from '../room/room';\n\nimport { Attack } from './attack';\nimport { BufferedThrottledInputController } from './inputController';\nimport { JumpController } from './jumpController';\n\n/** Player physics details */\nconst PLAYER_WIDTH = 14;\nconst PLAYER_HEIGHT = 18;\n\n/** Player speed per millisecond */\nconst SPEED = 450 / 1000;\nconst PLAYER_X_ACCEL = 8 / 1000;\nconst JUMP_MAGNITUDE = 1;\n\n/** Attack parameters */\nconst ATTACK_DURATION = 100;\nconst ATTACK_COOLDOWN = 250;\nconst ATTACK_BUFFER = 300;\n\nconst LEFT_KEY = 'a';\nconst DOWN_KEY = 's';\nconst RIGHT_KEY = 'd';\nconst ATTACK_KEY = 'j';\n\nconst PLAYER_SPRITE = Sprite('./img/sword_man.png');\n\nconst getImageCoordinates = (attacking: boolean, facing: 'left' | 'right', hasShield: boolean) => {\n    let x = 0, y = 0;\n    if (facing === 'right') {\n        x += PLAYER_WIDTH * 2;\n    }\n    if (attacking) {\n        y += PLAYER_HEIGHT * 2;\n    }\n    if (hasShield) {\n        x += PLAYER_WIDTH * 4;\n    }\n\n    return { x, y };\n};\n\nexport class PlayerState {\n    lastState: { x: number; y: number };\n    x: number;\n    y: number;\n    height: number;\n    width: number;\n\n    actor: Actor;\n\n    xVelocity: number;\n    yVelocity: number;\n\n    facing: 'left' | 'right';\n\n    jumpController: JumpController;\n    attackController: BufferedThrottledInputController;\n    attacks: Attack[];\n\n    constructor(x: number, y: number) {\n        x = Math.round(x);\n        y = Math.round(y);\n\n        this.lastState = { x, y };\n\n        this.x = x;\n        this.y = y;\n        this.height = PLAYER_HEIGHT * 2;\n        this.width = PLAYER_WIDTH * 2;\n\n        this.actor = new Actor(this.x - this.width, this.y - this.height, this.width * 2, this.height * 2);\n\n        this.xVelocity = 0;\n        this.yVelocity = 0;\n\n        this.facing = 'left';\n\n        this.jumpController = new JumpController();\n        this.attackController = new BufferedThrottledInputController(ATTACK_BUFFER, ATTACK_COOLDOWN, ATTACK_DURATION);\n\n        this.attacks = [];\n    }\n\n    draw(ctx: CanvasRenderingContext2D, _canvas: HTMLCanvasElement, _mousePosition: Vector | undefined, interpolationFactor: number) {\n        if (DRAW_FRAME_MARKERS) {\n            ctx.fillStyle = 'red';\n            ctx.fillRect(this.lastState.x - this.width, this.lastState.y - this.height, this.width * 2, this.height * 2);\n\n            ctx.fillStyle = 'green';\n            ctx.fillRect(this.x - this.width, this.y - this.height, this.width * 2, this.height * 2);\n        }\n\n        const xInterp = lerp(this.lastState.x, this.x, interpolationFactor);\n        const yInterp = lerp(this.lastState.y, this.y, interpolationFactor);\n\n        const isAttacking = this.attackController.isActive;\n        const attackTransparency = 1 - square(this.attackController.fractionThroughCooldown() ?? 0);\n\n        this.attacks.forEach(attack => {\n            attack.prePlayerDraw(ctx, { x: xInterp, y: yInterp }, attackTransparency);\n        });\n\n        const { x: sx, y: sy } = getImageCoordinates(isAttacking, this.facing, true);\n        ctx.drawImage(PLAYER_SPRITE, sx, sy, PLAYER_WIDTH * 2, PLAYER_HEIGHT * 2, xInterp - this.width, yInterp - this.height, this.width * 2, this.height * 2);\n\n        this.attacks.forEach(attack => {\n            attack.postPlayerDraw(ctx, { x: xInterp, y: yInterp }, attackTransparency);\n        });\n\n        if (DRAW_FRAME_MARKERS) {\n            ctx.strokeStyle = 'yellow';\n\n            ctx.strokeRect(this.actor.x, this.actor.y, this.actor.width, this.actor.height);\n        }\n    }\n\n    update(_mousePosition: Vector | undefined, keyboardState: Record<string, boolean>, frameDuration: number, room: Room) {\n        const solids = room.solids;\n        const enemies = room.enemies;\n\n        this.lastState = { x: this.x, y: this.y };\n\n        this.attackController.update(frameDuration, keyboardState[ATTACK_KEY], () => {\n            this.attacks = [new Attack(this.facing)];\n        });\n\n        if (!this.attackController.isActive) {\n            this.attacks = [];\n        }\n\n        this.attacks.forEach(attack => {\n            enemies.forEach(enemy => {\n                attack.interactWithEnemy(this.lastState, enemy);\n            });\n        });\n\n        const xInput = (keyboardState[RIGHT_KEY] ? 1 : 0) - (keyboardState[LEFT_KEY] ? 1 : 0);\n        const xVelocity = approach(xInput * SPEED, this.xVelocity, PLAYER_X_ACCEL);\n\n        const { yAcceleration, isJumping } = this.jumpController.update(keyboardState, frameDuration, this.yVelocity);\n\n        this.yVelocity += yAcceleration * frameDuration;\n\n        if (isJumping) {\n            const PARTICLE_RADIUS = 2;\n            for (let i = 0; i < 8; i++) {\n                const relX = randfloat(-1, 1);\n                room.addParticle(new Particle(\n                    this.actor.x + (1 + relX) * this.actor.width / 2 * 1 - PARTICLE_RADIUS,\n                    this.actor.y + this.actor.height - PARTICLE_RADIUS,\n                    PARTICLE_RADIUS * 2,\n                    PARTICLE_RADIUS * 2,\n                    'white',\n                    relX * 0.3,\n                    (Math.random() < 0.6 ? 1 : -1) * randfloat(0.15, 0.2),\n                    140,\n                ));\n            }\n\n            this.yVelocity = -JUMP_MAGNITUDE;\n        }\n\n        this.xVelocity = xVelocity;\n\n        if (xInput > 0) {\n            this.facing = 'right';\n        } else if (xInput < 0) {\n            this.facing = 'left';\n        }\n\n        this.actor.setDropping(keyboardState[DOWN_KEY]);\n\n        this.actor.moveX(this.xVelocity * frameDuration, () => { }, solids);\n        this.actor.moveY(this.yVelocity * frameDuration, () => { this.yVelocity = 0 }, solids);\n\n        this.x = this.actor.x + this.width;\n        this.y = this.actor.y + this.height;\n\n        const isGrounded = this.actor.isGrounded(solids);\n\n        this.jumpController.groundedCheck(isGrounded, isJumping);\n    }\n}\n", "import { DRAW_FRAME_MARKERS } from '../../constants';\nimport { Actor } from '../../core/actor';\nimport { incDecLatch, type IncDecLatch } from '../../core/latch';\nimport { approach, overlaps, type Rect, type Vector } from '../../core/math';\nimport { Sprite } from '../../core/sprite';\nimport type { Room } from '../room';\n\nimport type { EnemyInterface } from './interface';\n\nconst ENEMY_RADIUS = 24;\n\nconst X_SPEED = 300 / 1000;\nconst X_ACCEL = 2 / 1000;\nconst Y_ACCEL = 2 / 1000;\n\nconst GHOSTY_SPRITE = Sprite('./img/ghosty.png');\n\nconst ENEMY_WIDTH = 24;\nconst ENEMY_HEIGHT = 32;\nconst VISUAL_SCALE = 2;\n\nexport class Enemy implements EnemyInterface {\n    xVelocity: number;\n    yVelocity: number;\n\n    actor: Actor;\n\n    hp: number;\n    alive: boolean;\n\n    facing: 'left' | 'right';\n\n    isNonPhysical: boolean;\n\n    hurtVisualiser: IncDecLatch;\n\n    constructor(x: number, y: number) {\n        this.xVelocity = 0;\n        this.yVelocity = 0;\n\n        this.actor = new Actor(x, y, ENEMY_WIDTH * VISUAL_SCALE, ENEMY_HEIGHT * VISUAL_SCALE);\n\n        this.hp = 3;\n        this.alive = true;\n\n        this.facing = 'left';\n\n        this.isNonPhysical = true;\n\n        this.hurtVisualiser = incDecLatch(1, 250);\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        if (this.hurtVisualiser.check() > 0) {\n            ctx.filter = 'brightness(1000%) saturate(0%)';\n        }\n        ctx.drawImage(\n            GHOSTY_SPRITE,\n            this.facing === 'left' ? 0 : ENEMY_WIDTH,\n            0,\n            ENEMY_WIDTH,\n            ENEMY_HEIGHT,\n            this.actor.x,\n            this.actor.y,\n            this.actor.width,\n            this.actor.height,\n        );\n        ctx.filter = 'none';\n\n        if (DRAW_FRAME_MARKERS) {\n            ctx.strokeStyle = 'white';\n            ctx.strokeRect(this.actor.x, this.actor.y, this.actor.width, this.actor.height);\n        }\n    }\n\n    update(frameDuration: number, room: Room, playerPosition: { x: number; y: number }) {\n        this.updateVelocities(frameDuration, room, playerPosition);\n\n        if (this.isNonPhysical) {\n            this.actor.moveX(this.xVelocity * frameDuration, () => { }, []);\n            this.actor.moveY(this.yVelocity * frameDuration, () => { }, []);\n        } else {\n            this.actor.moveX(this.xVelocity * frameDuration, () => { this.xVelocity = 0 }, room.solids);\n            this.actor.moveY(this.yVelocity * frameDuration, () => { this.yVelocity = 0 }, room.solids);\n        }\n\n        this.hurtVisualiser.down(frameDuration);\n    }\n\n    updateVelocities(frameDuration: number, _room: Room, playerPosition: Vector) {\n        const myMidpoint = this.actor.getMidpoint();\n\n        if (playerPosition) {\n            if (playerPosition.x < myMidpoint.x) {\n                this.xVelocity = approach(-X_SPEED, this.xVelocity, X_ACCEL * frameDuration);\n\n                this.facing = 'left';\n            } else {\n                this.xVelocity = approach(X_SPEED, this.xVelocity, X_ACCEL * frameDuration);\n\n                this.facing = 'right';\n            }\n            if (playerPosition.y < myMidpoint.y) {\n                this.yVelocity = approach(-X_SPEED, this.yVelocity, Y_ACCEL * frameDuration);\n            } else {\n                this.yVelocity = approach(X_SPEED, this.yVelocity, Y_ACCEL * frameDuration);\n            }\n        } else {\n            this.facing = this.xVelocity < 0 ? 'left' : 'right';\n        }\n    }\n\n    applyDamage(_box: Rect, impulse: Partial<Vector>) {\n        this.hp -= 1;\n\n        this.xVelocity += impulse?.x ?? 0;\n        this.yVelocity += impulse?.y ?? 0;\n\n        if (this.hp <= 0) {\n            this.alive = false;\n        }\n\n        this.hurtVisualiser.up();\n    }\n\n    intersects(box: Rect) {\n        if (overlaps(box, this.actor)) {\n            return this.actor;\n        }\n    }\n}\n", "import { approach, overlaps, type Rect, type Vector } from '../../core/math';\nimport type { Room } from '../room';\n\nimport { Enemy } from './enemy';\n\nconst WALKING_SPEED = 180 / 1000;\nconst WALKING_ACCEL = 2 / 1000;\n\nconst GRAVITY = 2.5 / 1000;\n\nexport class Walker extends Enemy {\n    constructor(x: number, y: number) {\n        super(x, y);\n\n        this.hp = 5;\n\n        this.isNonPhysical = false;\n        this.facing = 'left';\n    }\n\n    updateVelocities(frameDuration: number, room: Room, _playerPosition: Vector) {\n        /** Do something */\n        this.yVelocity += GRAVITY * frameDuration;\n\n        const standingSolid = { x: this.actor.x, y: this.actor.y + this.actor.height, width: this.actor.width, height: 1 };\n\n        if (!room.solids.some(solid => solid.isCollidable && overlaps(solid, standingSolid))) {\n            /** Wait */\n            this.xVelocity = approach(0, this.xVelocity, WALKING_ACCEL / 2);\n        }\n\n        if (this.facing === 'left') {\n            if (this.canMoveLeft(room)) {\n                this.xVelocity = approach(-WALKING_SPEED, this.xVelocity, WALKING_ACCEL);\n            } else if (this.canMoveRight(room)) {\n                this.facing = 'right';\n                this.xVelocity = approach(0, this.xVelocity, WALKING_ACCEL);\n            }\n        } else {\n            /** Facing right case */\n            if (this.canMoveRight(room)) {\n                this.xVelocity = approach(WALKING_SPEED, this.xVelocity, WALKING_ACCEL);\n            } else if (this.canMoveLeft(room)) {\n                this.facing = 'left';\n                this.xVelocity = approach(0, this.xVelocity, WALKING_ACCEL);\n            }\n        }\n    }\n\n    canMoveLeft(room: Room) {\n        /** Currently taking for granted that we're on the ground. */\n\n        const groundSolid = { x: this.actor.x - this.actor.width / 2, y: this.actor.y + this.actor.height, width: this.actor.width / 4, height: 1 };\n        const spaceSolid = { x: this.actor.x - this.actor.width, y: this.actor.y, height: this.actor.height, width: this.actor.width };\n\n        return room.solids.some(solid => solid.isCollidable && !solid.isDroppable && overlaps(solid, groundSolid))\n            && room.solids.every(solid => !solid.isCollidable || !overlaps(solid, spaceSolid));\n    }\n\n    canMoveRight(room: Room) {\n        /** Currently taking for granted that we're on the ground. */\n\n        const groundSolid = { x: this.actor.x + this.actor.width / 4 * 5, y: this.actor.y + this.actor.height, width: this.actor.width / 4, height: 1 };\n        const spaceSolid = { x: this.actor.x + this.actor.width, y: this.actor.y, height: this.actor.height, width: this.actor.width };\n\n        return room.solids.some(solid => solid.isCollidable && !solid.isDroppable && overlaps(solid, groundSolid))\n            && room.solids.every(solid => !solid.isCollidable || solid.isDroppable || !overlaps(solid, spaceSolid));\n    }\n\n    applyDamage(box: Rect, impulse: Partial<Vector>) {\n        super.applyDamage(box, impulse);\n        this.yVelocity -= 0.3;\n    }\n}\n", "import type { Actor } from '../core/actor';\nimport { Solid } from '../core/solid';\n\nconst LOOP_DUR = 7000;\n\nexport class MovingPlatform {\n    solid: Solid;\n\n    timeTracked: number;\n\n    constructor(x: number, y: number, width: number, height: number) {\n        this.solid = new Solid(x, y, width, height);\n\n        this.timeTracked = 0;\n    }\n\n    update(frameDuration: number, actors: Actor[], solids: Solid[]) {\n        this.timeTracked += frameDuration;\n\n        const timeInCycle = this.timeTracked % LOOP_DUR;\n\n        const shouldBeInCycle = 300 + (timeInCycle > LOOP_DUR / 2 ? (LOOP_DUR - timeInCycle) / 7 : timeInCycle / 7);\n        this.solid.move(shouldBeInCycle - this.solid.x, 0, actors, solids);\n    }\n}", "import { Solid, type SolidConfig } from '../core/solid';\n\nimport { GAP_SIZE, GAPS, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH, WALL_THICKNESS, type DoorsMap, type HorizontalDoorKey, type VerticalDoorKey } from './room';\n\ntype SolidArgs =\n    (({ x: number } | { left: number; x?: undefined }) & ({ width: number } | { right: number; width?: undefined })) &\n    (({ y: number } | { top: number; y?: undefined }) & ({ height: number } | { bottom: number; height?: undefined }));\n\nexport const createSolid = (args: SolidArgs, config?: SolidConfig) => {\n    const x = args.x ?? args.left;\n    const y = args.y ?? args.top;\n    const width = args.width ?? args.right - x;\n    const height = args.height ?? args.bottom - y;\n\n    if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height)) {\n        throw new Error('Invalid parameters to create solid!');\n    }\n\n    return new Solid(x, y, width, height, config);\n}\n\nconst getGapNames = (gapMap: Partial<Record<VerticalDoorKey | HorizontalDoorKey, boolean | undefined>> = {}) => {\n    const names = (Object.keys(gapMap) as (VerticalDoorKey | HorizontalDoorKey)[]).filter(key => gapMap[key]);\n    names.sort((a, b) => GAPS[a][0] - GAPS[b][0]);\n    return names;\n};\n\nexport const getDoorBlockingSolids = (doors: Partial<DoorsMap>) => {\n    const solids = [];\n\n    solids.push(...getGapNames(doors.left).map(name => GAPS[name]).map(([top, bottom]) =>\n        createSolid({ top, bottom, left: 0, width: WALL_THICKNESS }),\n    ));\n    solids.push(...getGapNames(doors.right).map(name => GAPS[name]).map(([top, bottom]) =>\n        createSolid({ top, bottom, left: ROOM_SCALE_WIDTH - WALL_THICKNESS, width: WALL_THICKNESS }),\n    ));\n    solids.push(...getGapNames(doors.top).map(name => GAPS[name]).map(([left, right]) =>\n        createSolid({ left, right, top: 0, height: WALL_THICKNESS }),\n    ));\n    solids.push(...getGapNames(doors.bottom).map(name => GAPS[name]).map(([left, right]) =>\n        createSolid({ left, right, top: ROOM_SCALE_HEIGHT - WALL_THICKNESS, height: WALL_THICKNESS }),\n    ));\n\n    return solids;\n};\n\nexport const generateRoomForDoors = (doors: DoorsMap) => {\n    const solids = [];\n    const blockers = [];\n\n    const gapLeft = ROOM_SCALE_WIDTH / 2 - GAP_SIZE / 2;\n    const gapRight = gapLeft + GAP_SIZE;\n\n    /** Top */\n    const topStarts = [0].concat(getGapNames(doors.top).map(name => GAPS[name][1]));\n    const topEnds = getGapNames(doors.top).map(name => GAPS[name][0]).concat(ROOM_SCALE_WIDTH);\n    solids.push(...topStarts.map((left, index) =>\n        createSolid({ left, right: topEnds[index]!, y: 0, height: WALL_THICKNESS }),\n    ));\n    blockers.push(...getGapNames(doors.top).map(name => GAPS[name]).map(([left, right]) =>\n        createSolid({ left, right, y: 0, height: WALL_THICKNESS }),\n    ));\n\n    /** Bottom */\n    const bottomStarts = [0].concat(getGapNames(doors.bottom).map(name => GAPS[name][1]));\n    const bottomEnds = getGapNames(doors.bottom).map(name => GAPS[name][0]).concat(ROOM_SCALE_WIDTH);\n    solids.push(...bottomStarts.map((left, index) =>\n        createSolid({ left, right: bottomEnds[index]!, y: ROOM_SCALE_HEIGHT - WALL_THICKNESS, height: WALL_THICKNESS }),\n    ));\n    solids.push(...getGapNames(doors.bottom).map(name =>\n        createSolid(\n            { left: GAPS[name][0], right: GAPS[name][1], top: ROOM_SCALE_HEIGHT - WALL_THICKNESS, height: WALL_THICKNESS / 4 },\n            { isDroppable: true },\n        ),\n    ));\n    blockers.push(...getGapNames(doors.bottom).map(name => GAPS[name]).map(([left, right]) =>\n        createSolid({ left, right, y: ROOM_SCALE_HEIGHT - WALL_THICKNESS, height: WALL_THICKNESS }),\n    ));\n\n    /** Left */\n    const leftStarts = [0].concat(getGapNames(doors.left).map(name => GAPS[name][1]));\n    const leftEnds = getGapNames(doors.left).map(name => GAPS[name][0]).concat(ROOM_SCALE_HEIGHT);\n    solids.push(...leftStarts.map((top, index) =>\n        createSolid({ top, bottom: leftEnds[index]!, left: 0, width: WALL_THICKNESS }),\n    ));\n    blockers.push(...getGapNames(doors.left).map(name => GAPS[name]).map(([top, bottom]) =>\n        createSolid({ top, bottom, x: 0, width: WALL_THICKNESS }),\n    ));\n\n    /** Right */\n    const rightStarts = [0].concat(getGapNames(doors.right).map(name => GAPS[name][1]));\n    const rightEnds = getGapNames(doors.right).map(name => GAPS[name][0]).concat(ROOM_SCALE_HEIGHT);\n    solids.push(...rightStarts.map((top, index) =>\n        createSolid({ top, bottom: rightEnds[index]!, left: ROOM_SCALE_WIDTH - WALL_THICKNESS, width: WALL_THICKNESS }),\n    ));\n    blockers.push(...getGapNames(doors.right).map(name => GAPS[name]).map(([top, bottom]) =>\n        createSolid({ top, bottom, x: ROOM_SCALE_WIDTH - WALL_THICKNESS, width: WALL_THICKNESS }),\n    ));\n\n    const ladders = [];\n\n    /** Add left ladder */\n    ladders.push(createSolid(\n        { left: gapLeft - GAP_SIZE, width: GAP_SIZE, top: 420, height: WALL_THICKNESS / 4 },\n        { isDroppable: true },\n    ));\n    ladders.push(createSolid(\n        { left: gapLeft - GAP_SIZE, width: GAP_SIZE, top: 570, height: WALL_THICKNESS / 4 },\n        { isDroppable: true },\n    ));\n    /** Add top platform */\n    ladders.push(createSolid(\n        { left: gapLeft, right: gapRight, top: 140, height: WALL_THICKNESS / 4 },\n        { isDroppable: true },\n    ));\n\n    return {\n        blockers: blockers.map(blocker => {\n            blocker.blocker = true;\n            blocker.color = 'brown';\n            blocker.isCollidable = false;\n            return blocker;\n        }),\n        solids,\n        ladders,\n    };\n};\n", "import { overlaps, type Vector } from '../core/math';\nimport type { Solid } from '../core/solid';\nimport { PlayerState } from '../player/playerState';\nimport { Enemy } from './enemy/enemy';\nimport type { EnemyInterface } from './enemy/interface';\nimport { Walker } from './enemy/walker';\nimport { MovingPlatform } from './movingPlatform';\nimport type { Particle } from './particle';\nimport { generateRoomForDoors, getDoorBlockingSolids } from './room-utils';\n\nexport const WALL_THICKNESS = 40;\n\nexport const ROOM_SCALE_WIDTH = 1280;\nexport const ROOM_SCALE_HEIGHT = 720;\n\nexport const GAP_SIZE = WALL_THICKNESS * 6;\n\nexport const GAPS: Record<VerticalDoorKey | HorizontalDoorKey, [number, number]> = {\n    high: [120, 240],\n    medium: [ROOM_SCALE_HEIGHT / 2 - 40, ROOM_SCALE_HEIGHT / 2 + 80],\n    low: [ROOM_SCALE_HEIGHT - 160, ROOM_SCALE_HEIGHT - 40],\n\n    left: [80, 280],\n    center: [ROOM_SCALE_WIDTH / 2 - 100, ROOM_SCALE_WIDTH / 2 + 100],\n    right: [ROOM_SCALE_WIDTH - 280, ROOM_SCALE_WIDTH - 80],\n};\n\nexport type VerticalDoorKey = 'left' | 'center' | 'right';\nexport type HorizontalDoorKey = 'high' | 'medium' | 'low';\n\nconst VERTICAL_DOOR_KEYS: VerticalDoorKey[] = ['left', 'center', 'right'];\nconst HORIZONTAL_DOOR_KEYS: HorizontalDoorKey[] = ['high', 'medium', 'low'];\n\nconst OPPOSITE_FACE = {\n    left: 'right',\n    right: 'left',\n    top: 'bottom',\n    bottom: 'top',\n};\n\nexport type Edge = 'left' | 'right' | 'top' | 'bottom';\n\nexport type DoorsMap = {\n    left: Partial<Record<HorizontalDoorKey, boolean | undefined>>;\n    right: Partial<Record<HorizontalDoorKey, boolean | undefined>>;\n    top: Partial<Record<VerticalDoorKey, boolean | undefined>>;\n    bottom: Partial<Record<VerticalDoorKey, boolean | undefined>>;\n}\n\nexport type SemiDoorsMap = {\n    left: Partial<Record<HorizontalDoorKey, boolean | undefined>> | undefined;\n    right: Partial<Record<HorizontalDoorKey, boolean | undefined>> | undefined;\n    top: Partial<Record<VerticalDoorKey, boolean | undefined>> | undefined;\n    bottom: Partial<Record<VerticalDoorKey, boolean | undefined>> | undefined;\n};\n\nexport class Room {\n    getDoorwayChance() {\n        return 0.5;\n    }\n\n    static getDoorArrangement(): DoorsMap {\n        return {\n            top: {},\n            bottom: {},\n            left: {},\n            right: {},\n        };\n    }\n\n    static isValidAt(_x: number, _y: number) {\n        return true;\n    }\n\n    /** Default room constructor works for any door arrangement */\n    static areDoorsOk(setDoors: DoorsMap) {\n        const arr = this.getDoorArrangement();\n\n        return HORIZONTAL_DOOR_KEYS.every(key => {\n            return (arr.left[key] === undefined || setDoors.left[key] === undefined || arr.left[key] === setDoors.left[key])\n                && (arr.right[key] === undefined || setDoors.right[key] === undefined || arr.right[key] === setDoors.right[key]);\n        }) && VERTICAL_DOOR_KEYS.every(key => {\n            return (arr.top[key] === undefined || setDoors.top[key] === undefined || arr.top[key] === setDoors.top[key])\n                && (arr.bottom[key] === undefined || setDoors.bottom[key] === undefined || arr.bottom[key] === setDoors.bottom[key]);\n        });\n    }\n\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n\n    color: string;\n\n    blockersLocked: boolean;\n    allEnemiesCleared: boolean;\n\n    doors: DoorsMap;\n\n    enemies: EnemyInterface[];\n    solids: Solid[];\n    interactives: MovingPlatform[];\n    particles: Particle[];\n\n    playerState: PlayerState;\n\n    constructor(x: number, y: number, width: number, height: number, color = 'blue', setDoors: Partial<DoorsMap> | undefined = {}) {\n        /** Room setup */\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        this.color = color;\n\n        this.blockersLocked = false;\n        this.allEnemiesCleared = false;\n\n        this.doors = {\n            left: setDoors.left ?? {},\n            right: setDoors.right ?? {},\n            top: setDoors.top ?? {},\n            bottom: setDoors.bottom ?? {},\n        };\n\n        this.enemies = [];\n        this.solids = [];\n        this.interactives = [];\n        this.particles = [];\n\n        this.globalDoorwayRectification();\n        this.configureAllDoors();\n        this.configureRoomContent();\n\n        /** Player setup */\n        this.playerState = new PlayerState(0.5 * ROOM_SCALE_WIDTH, 0.12 * ROOM_SCALE_HEIGHT);\n    }\n\n    globalDoorwayRectification() {\n        /** Basic doorway rectification rules */\n        if (this.x === 0 && this.y === 0) {\n            this.doors = {\n                bottom: { center: true, left: false, right: false },\n                top: { center: false, left: false, right: false },\n                left: { high: false, medium: false, low: false },\n                right: { high: false, medium: false, low: false },\n            };\n        } else if (this.x === 0 && this.y === 1) {\n            this.doors.top = { center: true, left: false, right: false };\n        } else if (this.y === 1) {\n            this.doors.top = { center: false, left: false, right: false };\n        }\n    }\n\n    /** Randomise un-specified doors */\n    configureAllDoors() {\n        const arr = Room.getDoorArrangement();\n        const odds = this.getDoorwayChance();\n\n        HORIZONTAL_DOOR_KEYS.forEach(key => {\n            if (this.doors.left[key] === undefined) {\n                this.doors.left[key] = arr.left[key] ?? Math.random() < odds;\n            }\n            if (this.doors.right[key] === undefined) {\n                this.doors.right[key] = arr.right[key] ?? Math.random() < odds;\n            }\n        });\n        VERTICAL_DOOR_KEYS.forEach(key => {\n            if (this.doors.top[key] === undefined) {\n                this.doors.top[key] = arr.top[key] ?? Math.random() < odds;\n            }\n            if (this.doors.bottom[key] === undefined) {\n                this.doors.bottom[key] = arr.bottom[key] ?? Math.random() < odds;\n            }\n        });\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { solids, blockers, ladders } = generateRoomForDoors(this.doors);\n        this.solids = solids.concat(blockers).concat(ladders);\n        this.interactives = [new MovingPlatform(0, 280, 200, 40)];\n        this.solids.push(...this.interactives.map(i => i.solid));\n\n        this.enemies = [\n            new Enemy(ROOM_SCALE_WIDTH, ROOM_SCALE_HEIGHT),\n            new Walker(ROOM_SCALE_WIDTH / 4 * 3, ROOM_SCALE_HEIGHT / 2),\n        ];\n    }\n\n    draw(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, mousePosition: Vector | undefined, interpolationFactor: number) {\n        /** Blank background */\n        ctx.fillStyle = 'black';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n        for (const solid of this.solids) {\n            if (solid.color) {\n                ctx.fillStyle = solid.color;\n            } else {\n                ctx.fillStyle = this.color;\n            }\n            ctx.fillRect(solid.x, solid.y, solid.width, solid.height);\n        }\n\n        /** Draw particles */\n        this.particles.forEach(particle => {\n            particle.draw(ctx);\n        });\n\n        /** Draw enemies */\n        this.enemies.forEach(enemy => {\n            enemy.draw(ctx);\n        });\n\n        /** Draw player */\n        ctx.fillStyle = 'white';\n        this.playerState.draw(ctx, canvas, mousePosition, interpolationFactor);\n    }\n\n    update(mousePosition: Vector | undefined, keyboardState: Record<string, boolean>, frameDuration: number, onRoomChange: (x: number, y: number, doors: Partial<DoorsMap>) => void) {\n        if (!this.blockersLocked) {\n            if (this.solids.some(solid => solid.blocker && overlaps(this.playerState.actor, solid))) {\n                // Not yet\n            } else {\n                this.solids.forEach(solid => {\n                    if (solid.blocker) {\n                        solid.isCollidable = true;\n                    }\n                });\n                this.blockersLocked = true;\n            }\n        }\n\n        this.particles = this.particles.filter(particle => {\n            particle.update(frameDuration);\n\n            return particle.alive;\n        });\n\n        this.interactives.forEach(interactive => {\n            interactive.update(frameDuration, [this.playerState.actor], this.solids);\n        });\n\n        this.enemies.forEach(enemy => {\n            enemy.update(frameDuration, this, this.playerState.actor.getMidpoint());\n        });\n\n        this.playerState.update(mousePosition, keyboardState, frameDuration, this);\n\n        this.enemies = this.enemies.filter(enemy => enemy.alive);\n\n        if (!this.allEnemiesCleared && this.enemies.length === 0) {\n            this.onAllEnemiesCleared();\n            this.allEnemiesCleared = true;\n        }\n\n        this.validateLeavingRoom(onRoomChange);\n    }\n\n    validateLeavingRoom(onRoomChange: (x: number, y: number, doors: Partial<DoorsMap>) => void) {\n        const playerMidpoint = this.playerState.actor.getMidpoint();\n        if (playerMidpoint.x > ROOM_SCALE_WIDTH) {\n            const doors: Pick<DoorsMap, 'left'> = { left: {} };\n            const relevantGap = (['high', 'medium', 'low'] as const)\n                .find(gap => playerMidpoint.y >= GAPS[gap][0] && playerMidpoint.y < GAPS[gap][1]);\n            if (relevantGap) doors.left[relevantGap] = true;\n            onRoomChange(this.x + 1, this.y, doors);\n        } else if (playerMidpoint.x < 0) {\n            const doors: Pick<DoorsMap, 'right'> = { right: {} };\n            const relevantGap = (['high', 'medium', 'low'] as const)\n                .find(gap => playerMidpoint.y >= GAPS[gap][0] && playerMidpoint.y < GAPS[gap][1]);\n            if (relevantGap) doors.right[relevantGap] = true;\n            onRoomChange(this.x - 1, this.y, doors);\n        } else if (playerMidpoint.y > ROOM_SCALE_HEIGHT) {\n            const doors: Pick<DoorsMap, 'top'> = { top: {} };\n            const relevantGap = (['left', 'center', 'right'] as const)\n                .find(gap => playerMidpoint.x >= GAPS[gap][0] && playerMidpoint.x < GAPS[gap][1]);\n            if (relevantGap) doors.top[relevantGap] = true;\n            onRoomChange(this.x, this.y + 1, doors);\n        } else if (playerMidpoint.y < 0) {\n            const doors: Pick<DoorsMap, 'bottom'> = { bottom: {} };\n            const relevantGap = (['left', 'center', 'right'] as const)\n                .find(gap => playerMidpoint.x >= GAPS[gap][0] && playerMidpoint.x < GAPS[gap][1]);\n            if (relevantGap) doors.bottom[relevantGap] = true;\n            onRoomChange(this.x, this.y - 1, doors);\n        }\n    }\n\n    onAllEnemiesCleared() {\n        this.solids = this.solids.filter(solid => !solid.blocker);\n    }\n\n    setExternalMatchingDoorways(doors: Partial<SemiDoorsMap>) {\n        const doorsToBlock: Partial<DoorsMap> = {};\n\n        for (const _face in doors) {\n            const face = _face as keyof DoorsMap;\n\n            for (const _doorway in doors[face]) {\n                const doorway = face === 'left' || face === 'right'\n                    ? _doorway as HorizontalDoorKey\n                    : _doorway as VerticalDoorKey;\n\n                if (face === 'left' || face === 'right') {\n                    const doorway = _doorway as HorizontalDoorKey;\n\n                    if (doors[face][doorway] === false && this.doors[face][doorway] === true) {\n                        doorsToBlock[face] = doorsToBlock[face] ?? {};\n                        doorsToBlock[face][doorway] = true;\n                    }\n                } else {\n                    const doorway = _doorway as VerticalDoorKey;\n\n                    if (doors[face][doorway] === false && this.doors[face][doorway] === true) {\n                        doorsToBlock[face] = doorsToBlock[face] ?? {};\n                        doorsToBlock[face][doorway] = true;\n                    }\n                }\n            }\n        }\n\n        this.solids.push(...getDoorBlockingSolids(doorsToBlock).map(solid => {\n            solid.color = 'yellow';\n            return solid;\n        }));\n    }\n\n    drawForMap(mapCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D) {\n        mapCtx.fillStyle = this.color;\n\n        for (const solid of this.solids) {\n            if (solid.blocker) {\n                continue;\n            }\n            mapCtx.fillRect(solid.x, solid.y, solid.width, solid.height);\n        }\n    }\n\n    addParticle(particle: Particle) {\n        this.particles.push(particle);\n    }\n}\n", "import { DRAW_FRAME_MARKERS } from '../../../constants';\nimport { incDecLatch, type IncDecLatch } from '../../../core/latch';\nimport { distance, isPointInside, normalize, overlaps, randomPerimeterPoint, randomPointInRect, rectMidpoint, type Rect, type Vector } from '../../../core/math';\nimport { Sprite } from '../../../core/sprite';\nimport { Particle } from '../../particle';\nimport { Room, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH } from '../../room';\n\nconst GHOST_WIDTH = 200;\nconst GHOST_COLLIDER_WIDTH = 120;\n\nconst GHOST_BOSS_SPEED = 500 / 1000;\n\nconst GhostBossSprite = Sprite('./img/theghost.png');\n\nconst INSIDE_COLLIDER = {\n    x: 100,\n    y: 100,\n    width: ROOM_SCALE_WIDTH - 200,\n    height: ROOM_SCALE_HEIGHT - 200,\n};\n\nconst SCREEN_COLLIDER = {\n    x: -100,\n    y: -100,\n    width: ROOM_SCALE_WIDTH + 200,\n    height: ROOM_SCALE_HEIGHT + 200,\n};\n\nexport class GhostBoss {\n    hp: number;\n    alive: boolean;\n\n    isNonPhysical: boolean;\n    facing: 'left' | 'right';\n    x: number;\n    y: number;\n\n    xVelocity: number = 0;\n    yVelocity: number = 0;\n\n    collider: Rect;\n\n    hurtVisualiser: IncDecLatch;\n    particleCooldown: IncDecLatch;\n\n    strategy: 'initialWait' | 'flee' | 'charge';\n\n    isStrategyComplete: boolean;\n\n    distFromStart: () => number;\n    distFromTarget: () => number;\n\n    constructor(x: number, y: number) {\n        this.hp = 20;\n        this.alive = true;\n\n        this.isNonPhysical = false;\n        this.facing = 'left';\n\n        this.x = x;\n        this.y = y;\n\n        this.collider = {\n            x: this.x - GHOST_COLLIDER_WIDTH / 2,\n            y: this.y - GHOST_COLLIDER_WIDTH / 2,\n            width: GHOST_COLLIDER_WIDTH,\n            height: GHOST_COLLIDER_WIDTH,\n        };\n\n        this.hurtVisualiser = incDecLatch(1, 250);\n        this.particleCooldown = incDecLatch(1, 40);\n\n        this.strategy = 'initialWait';\n        this.isStrategyComplete = false;\n\n        this.distFromStart = () => 0;\n        this.distFromTarget = () => 0;\n    }\n\n    update(frameDuration: number, room: Room, playerPosition: Vector) {\n        this.hurtVisualiser.down(frameDuration);\n        this.particleCooldown.down(frameDuration);\n\n        switch (this.strategy) {\n            case 'initialWait':\n                if (isPointInside(INSIDE_COLLIDER, playerPosition.x, playerPosition.y)) {\n                    this.initFlee(playerPosition);\n                }\n                return;\n            case 'flee':\n                const fleeSpeedMod = 0.8 + Math.min(1.2, this.distFromStart() / 600);\n                this.collider.x += this.xVelocity * frameDuration * fleeSpeedMod;\n                this.collider.y += this.yVelocity * frameDuration * fleeSpeedMod;\n\n                if (!overlaps(SCREEN_COLLIDER, this.collider)) {\n                    this.initCharge(playerPosition);\n                }\n\n                this.addParticle(room);\n                return;\n            case 'charge':\n                const speedMod = 0.8 + Math.min(1.2, this.distFromTarget() / 600);\n                this.collider.x += this.xVelocity * frameDuration * speedMod;\n                this.collider.y += this.yVelocity * frameDuration * speedMod;\n\n                if (this.distFromTarget() <= 10) {\n                    this.initFlee(playerPosition);\n                }\n\n                this.addParticle(room);\n                return;\n        }\n    }\n\n    addParticle(room: Room) {\n        if (this.particleCooldown.check() <= 0) {\n            const pPos = randomPointInRect(this.collider);\n            const RADIUS = 4;\n            room.addParticle(new Particle(\n                pPos.x - RADIUS / 2,\n                pPos.y - RADIUS / 2,\n                4,\n                4,\n                'white',\n                this.xVelocity * 0.1,\n                this.yVelocity * 0.1,\n                360,\n                true,\n            ));\n            this.particleCooldown.up(1);\n        }\n    }\n\n    initFlee(playerPosition: Vector) {\n        this.strategy = 'flee';\n\n        const startingPoint = rectMidpoint(this.collider);\n\n        const direction = {\n            x: playerPosition.x - startingPoint.x,\n            y: playerPosition.y - startingPoint.y,\n        };\n        const speed = normalize(direction, GHOST_BOSS_SPEED);\n\n        this.xVelocity = speed.x;\n        this.yVelocity = speed.y;\n\n        this.distFromStart = () => {\n            return distance(rectMidpoint(this.collider), startingPoint);\n        }\n    }\n\n    initCharge(playerPosition: Vector) {\n        this.strategy = 'charge';\n\n        /** Choose new starting point */\n        const startingPoint = randomPerimeterPoint(SCREEN_COLLIDER);\n\n        this.collider.x = startingPoint.x - GHOST_COLLIDER_WIDTH / 2;\n        this.collider.y = startingPoint.y - GHOST_COLLIDER_WIDTH / 2;\n\n        const px = playerPosition.x;\n        const py = playerPosition.y;\n\n        const direction = {\n            x: px - startingPoint.x,\n            y: py - startingPoint.y,\n        };\n        const speed = normalize(direction, GHOST_BOSS_SPEED);\n\n        this.xVelocity = speed.x;\n        this.yVelocity = speed.y;\n\n        this.distFromTarget = () => {\n            const pos = rectMidpoint(this.collider);\n\n            return distance(pos, { x: px, y: py });\n        };\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        if (this.hurtVisualiser.check() > 0) {\n            ctx.filter = 'brightness(10000%) saturate(0%)';\n        }\n\n        const x = Math.round(this.collider.x);\n        const y = Math.round(this.collider.y);\n\n        const OFFSET = (GHOST_WIDTH - GHOST_COLLIDER_WIDTH) / 2;\n        ctx.drawImage(\n            GhostBossSprite,\n            0,\n            0,\n            GhostBossSprite.width,\n            GhostBossSprite.height,\n            x - OFFSET,\n            y - OFFSET,\n            this.collider.width + 2 * OFFSET,\n            this.collider.height + 2 * OFFSET,\n        );\n\n        ctx.filter = 'none';\n\n        if (DRAW_FRAME_MARKERS) {\n            ctx.strokeStyle = 'yellow';\n            ctx.strokeRect(x, y, this.collider.width, this.collider.height);\n        }\n    }\n\n    applyDamage(_box: Rect) {\n        this.hp -= 1;\n        this.hurtVisualiser.up(1);\n\n        if (this.hp < 0) {\n            this.alive = false;\n        }\n    }\n\n    intersects(box: Rect) {\n        if (overlaps(box, this.collider)) {\n            return this.collider;\n        }\n    }\n}\n", "import { Solid } from '../../core/solid';\nimport { GhostBoss } from '../enemy/bosses/ghost-boss';\nimport { Room, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH } from '../room';\nimport { generateRoomForDoors } from '../room-utils';\n\nexport class GhostRoom extends Room {\n    getDoorwayChance() {\n        return 0;\n    }\n\n    static getDoorArrangement() {\n        return {\n            left: {\n                high: true,\n                medium: false,\n                low: false\n            },\n            right: {\n                high: true,\n                medium: false,\n                low: false,\n            },\n            bottom: {\n                left: false,\n                center: false,\n                right: false,\n            },\n            top: {\n                left: false,\n                center: false,\n                right: false,\n            },\n        };\n    }\n\n    static isValidAt() {\n        return true;\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { solids, blockers } = generateRoomForDoors(this.doors);\n        this.solids = solids\n            .concat(blockers)\n            .concat(\n                ...[240, 390, 540].map(y =>\n                    new Solid(40, y, ROOM_SCALE_WIDTH - 80, 10, { isDroppable: true }),\n                ),\n            );\n\n        this.enemies = [\n            new GhostBoss(ROOM_SCALE_WIDTH / 2, ROOM_SCALE_HEIGHT / 2),\n        ];\n    }\n}\n", "import { Solid } from '../../core/solid';\nimport { Room, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH } from '../room';\nimport { generateRoomForDoors } from '../room-utils';\n\nexport class HRoom extends Room {\n    getDoorwayChance() {\n        return 0;\n    }\n\n    static getDoorArrangement() {\n        return {\n            left: {\n                high: false,\n                medium: false,\n                low: false\n            },\n            right: {\n                high: false,\n                medium: false,\n                low: false,\n            },\n            bottom: {\n                left: true,\n                center: false,\n                right: true,\n            },\n            top: {\n                left: true,\n                center: false,\n                right: true,\n            },\n        };\n    }\n\n    static isValidAt(_x: number, y: number) {\n        return y >= 2;\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { blockers } = generateRoomForDoors(this.doors);\n        this.solids = blockers\n            .concat(\n                new Solid(0, 0, 80, ROOM_SCALE_HEIGHT),\n                new Solid(ROOM_SCALE_WIDTH - 80, 0, 80, ROOM_SCALE_HEIGHT),\n                new Solid(280, 0, 720, 260),\n                new Solid(280, 460, 720, 260),\n                /** Lower left leg */\n                new Solid(80, ROOM_SCALE_HEIGHT - 40, 200, 10, { isDroppable: true }),\n                new Solid(120, 570, 120, 10, { isDroppable: true }),\n                new Solid(80, 460, 200, 10, { isDroppable: true }),\n                /** Upper left leg */\n                new Solid(80, 120, 200, 10, { isDroppable: true }),\n                new Solid(80, 250, 200, 10, { isDroppable: true }),\n                new Solid(80, 355, 100, 10, { isDroppable: true }),\n                /** Lower right leg */\n                new Solid(1000, ROOM_SCALE_HEIGHT - 40, 200, 10, { isDroppable: true }),\n                new Solid(1040, 570, 120, 10, { isDroppable: true }),\n                new Solid(1000, 460, 200, 10, { isDroppable: true }),\n                /** Upper right leg */\n                new Solid(1000, 120, 200, 10, { isDroppable: true }),\n                new Solid(1000, 250, 200, 10, { isDroppable: true }),\n                new Solid(1100, 355, 100, 10, { isDroppable: true }),\n            );\n    }\n}\n", "import { Solid } from '../../core/solid';\nimport { Room, ROOM_SCALE_WIDTH, type HorizontalDoorKey, type VerticalDoorKey } from '../room';\nimport { generateRoomForDoors } from '../room-utils';\n\nexport class LRoom extends Room {\n    getDoorwayChance() {\n        return 0.1;\n    }\n\n    static getDoorArrangement() {\n        return {\n            left: {},\n            right: {\n                high: false,\n                medium: false,\n                low: true,\n            },\n            bottom: {},\n            top: {\n                left: true,\n                center: false,\n                right: false,\n            },\n        };\n    }\n\n    static isValidAt(_x: number, y: number) {\n        return y >= 2;\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { solids, blockers } = generateRoomForDoors(this.doors);\n        this.solids = solids\n            .concat(blockers)\n            .concat(\n                new Solid(380, 0, ROOM_SCALE_WIDTH - 380, 450),\n                new Solid(120, 140, 120, 10, { isDroppable: true }),\n                new Solid(40, 240, 340, 10, { isDroppable: true }),\n                new Solid(this.doors?.left?.['center' as HorizontalDoorKey] ? 160 : 40, 340, this.doors.left['center' as HorizontalDoorKey] ? 220 : 340, 10, { isDroppable: true }),\n                new Solid(40, 440, 340, 10, { isDroppable: true }),\n                new Solid(40, this.doors.left['low'] ? 550 : 540, 240, 10, { isDroppable: true }),\n            );\n    }\n}\n", "import { DRAW_FRAME_MARKERS } from \"../../../constants\";\nimport { Actor } from \"../../../core/actor\";\nimport { incDecLatch, type IncDecLatch } from \"../../../core/latch\";\nimport { clampPointWithin, insetRect, overlaps, randfloat, randint, rectMidpoint, type Rect, type Vector } from \"../../../core/math\";\nimport type { Solid } from \"../../../core/solid\";\nimport { Sprite } from \"../../../core/sprite\";\nimport { Particle } from \"../../particle\";\nimport type { Room } from \"../../room\";\nimport type { EnemyInterface } from \"../interface\";\n\nconst SPITBOSS_BASE_WIDTH = 340;\nconst SPITBOSS_BASE_HEIGHT = 76;\n\nconst SPITBOSS_HEAD_WIDTH = 60;\nconst SPITBOSS_HEAD_HEIGHT = 80;\n\nconst GRAVITY = 2.5 / 1000;\n\nconst SpitBossHeadSprite = Sprite('./img/spitboss-head.png');\nconst SpitBossBaseSprite = Sprite('./img/spitboss-base.png');\nconst SpitBossSpitSprite = Sprite('./img/spitboss-spit.png');\n\nexport class SpitBoss implements EnemyInterface {\n    hp: number;\n    alive: boolean;\n\n    isNonPhysical: boolean;\n\n    x: number;\n    y: number;\n    baseBox: Rect;\n    headBox: Rect;\n\n    hurtVisualiser: IncDecLatch;\n    fireCooldown: IncDecLatch;\n\n    constructor(x: number, y: number) {\n        this.hp = 50;\n        this.alive = true;\n\n        this.isNonPhysical = false;\n\n        this.x = x;\n        this.y = y;\n\n        this.baseBox = {\n            x: this.x - SPITBOSS_BASE_WIDTH / 2,\n            y: this.y - SPITBOSS_BASE_HEIGHT,\n            width: SPITBOSS_BASE_WIDTH,\n            height: SPITBOSS_BASE_HEIGHT,\n        };\n\n        this.headBox = {\n            x: this.x - SPITBOSS_HEAD_WIDTH / 2,\n            y: Math.round(this.y - SPITBOSS_HEAD_HEIGHT - 0.75 * SPITBOSS_BASE_HEIGHT),\n            width: SPITBOSS_HEAD_WIDTH,\n            height: SPITBOSS_HEAD_HEIGHT,\n        };\n\n        this.hurtVisualiser = incDecLatch(1, 250);\n        this.fireCooldown = incDecLatch(1, 1200);\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        if (this.hurtVisualiser.check() > 0) {\n            ctx.filter = 'brightness(1000%) saturate(0%)';\n        }\n\n        const BASE_WIDTH_OFF = 8;\n        const BASE_HEIGHT_OFF = 8;\n        ctx.drawImage(\n            SpitBossBaseSprite,\n            0,\n            0,\n            SpitBossBaseSprite.width,\n            SpitBossBaseSprite.height,\n            this.baseBox.x - BASE_WIDTH_OFF,\n            this.baseBox.y - BASE_HEIGHT_OFF,\n            this.baseBox.width + 2 * BASE_WIDTH_OFF,\n            this.baseBox.height + BASE_HEIGHT_OFF,\n        );\n\n        const HEAD_OFF = 4;\n        ctx.drawImage(\n            SpitBossHeadSprite,\n            0,\n            0,\n            SpitBossHeadSprite.width,\n            SpitBossHeadSprite.height,\n            this.headBox.x - HEAD_OFF,\n            this.headBox.y - HEAD_OFF,\n            this.headBox.width + 2 * HEAD_OFF,\n            this.headBox.height + 2 * HEAD_OFF,\n        );\n\n        ctx.filter = 'none';\n\n        if (DRAW_FRAME_MARKERS) {\n            ctx.strokeStyle = 'grey';\n            ctx.strokeRect(this.baseBox.x, this.baseBox.y, this.baseBox.width, this.baseBox.height);\n\n            ctx.strokeStyle = 'yellow';\n            ctx.strokeRect(this.headBox.x, this.headBox.y, this.headBox.width, this.headBox.height);\n        }\n    }\n\n    update(frameDuration: number, room: Room, playerPosition: Vector) {\n        this.hurtVisualiser.down(frameDuration);\n\n        this.fireCooldown.down(frameDuration);\n\n        if (this.fireCooldown.check() === 0) {\n            const newProjectiles = this.createProjectile(room, playerPosition);\n\n            if (newProjectiles && newProjectiles.length > 0) {\n                this.fireCooldown.up(1);\n                room.enemies.push(...newProjectiles);\n            }\n        }\n    }\n\n    createProjectile(room: Room, playerPosition: Vector) {\n        const aboveCollider = {\n            x: this.x - 5,\n            width: 10,\n            y: 0,\n            height: this.y,\n        };\n\n        const solidsAboveMe = room.solids.filter(solid => solid.isCollidable && !solid.isDroppable && overlaps(solid, aboveCollider));\n        const maxY = solidsAboveMe.reduce((maxY, solid) => {\n            return Math.max(maxY, solid.y + solid.height);\n        }, 0);\n\n        const startingY = this.y - 100;\n\n        const acceptablePeak = startingY - maxY - SPITBALL_RADIUS;\n\n        const maxYVelocity = -Math.sqrt(2 * GRAVITY * acceptablePeak);\n\n        if (playerPosition.y <= acceptablePeak) {\n            return undefined;\n        }\n\n        const yVelocity = randfloat(0.8, 1.0) * maxYVelocity;\n\n        const determinant = yVelocity * yVelocity - 2 * GRAVITY * (startingY - playerPosition.y);\n\n        if (determinant <= 0) {\n            return undefined;\n        }\n\n        const timeToPlayerY = (-yVelocity + Math.sqrt(determinant)) / GRAVITY;\n        const xVelocity = (playerPosition.x - this.x) / timeToPlayerY;\n\n        const numToThrow = randint(1, 4);\n\n        return new Array(numToThrow).fill(0).map(() =>\n            new SpitBoss_Spit(\n                this.x,\n                startingY,\n                xVelocity + randfloat(-0.1, 0.1),\n                yVelocity + randfloat(-0.01, 0.1),\n                this,\n            ),\n        );\n    }\n\n    applyDamage(box: Rect) {\n        if (box === this.headBox) {\n            this.hp -= 3;\n            this.hurtVisualiser.up(1);\n        } else if (box === this.baseBox) {\n            this.hp -= 0.2;\n            this.hurtVisualiser.up(0.2);\n        }\n\n        if (this.hp < 0) {\n            this.alive = false;\n        }\n    }\n\n    intersects(box: Rect) {\n        if (overlaps(box, this.headBox)) {\n            return this.headBox;\n        } else if (overlaps(box, this.baseBox)) {\n            return this.baseBox;\n        }\n    }\n}\n\nconst SPITBALL_RADIUS = 14;\n\nclass SpitBoss_Spit implements EnemyInterface {\n    actor: Actor;\n    xVelocity: number;\n    yVelocity: number;\n\n    parent: SpitBoss;\n\n    alive: boolean;\n    struck: boolean;\n\n    hitVisualiser: IncDecLatch;\n\n    constructor(x: number, y: number, xVel: number, yVel: number, parent: SpitBoss) {\n        this.actor = new Actor(x - SPITBALL_RADIUS, y - SPITBALL_RADIUS, SPITBALL_RADIUS * 2, SPITBALL_RADIUS * 2);\n\n        this.xVelocity = xVel;\n        this.yVelocity = yVel;\n\n        this.parent = parent;\n\n        this.alive = true;\n\n        this.struck = false;\n\n        this.hitVisualiser = incDecLatch(1, 150);\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        const OFFSET = 2;\n        ctx.drawImage(\n            SpitBossSpitSprite,\n            0,\n            0,\n            SpitBossSpitSprite.width,\n            SpitBossSpitSprite.height,\n            this.actor.x - OFFSET,\n            this.actor.y - OFFSET,\n            this.actor.width + 2 * OFFSET,\n            this.actor.height + 2 * OFFSET,\n        );\n    }\n\n    addParticle(room: Room, origin: Vector, velocity: Vector) {\n        const PARTICLE_RADIUS = 3;\n\n        room.addParticle(new Particle(\n            origin.x - PARTICLE_RADIUS,\n            origin.y - PARTICLE_RADIUS,\n            PARTICLE_RADIUS * 2,\n            PARTICLE_RADIUS * 2,\n            Math.random() > 0.5 ? '#674cd3' : '#9e5eff',\n            velocity.x,\n            velocity.y,\n            randfloat(120, 200),\n            true,\n        ));\n    }\n\n    update(frameDuration: number, room: Room, _playerPosition: Vector) {\n        this.hitVisualiser.down(frameDuration);\n\n        const wallHit = (drn: 'x' | 'y') => (solid: Solid) => {\n            this.alive = false;\n\n            const origin = drn === 'x'\n                ? {\n                    x: this.xVelocity > 0 ? solid.x : solid.x + solid.width,\n                    y: this.actor.y + this.actor.height / 2,\n                }\n                : {\n                    x: this.actor.x + this.actor.width / 2,\n                    y: this.yVelocity > 0 ? solid.y : solid.y + solid.height,\n                };\n\n            for (let i = 0; i < 12; i++) {\n                const vel = drn === 'x'\n                    ? {\n                        x: -this.xVelocity * randfloat(0.4, 0.6),\n                        y: randfloat(-0.2, 0.2),\n                    }\n                    : {\n                        x: randfloat(-0.2, 0.2),\n                        y: -this.yVelocity * randfloat(0.2, 0.3),\n                    };\n\n                this.addParticle(room, origin, vel);\n            }\n        };\n\n        this.yVelocity += GRAVITY * frameDuration;\n        this.actor.moveX(this.xVelocity * frameDuration, wallHit('x'), room.solids);\n        this.actor.moveY(this.yVelocity * frameDuration, wallHit('y'), room.solids);\n\n        /** See if we apply damage to parent */\n        if (this.struck && this.parent.alive) {\n            const hitBox = this.parent.intersects(this.actor);\n\n            if (hitBox) {\n                this.parent.applyDamage(hitBox);\n\n                const origin = clampPointWithin(rectMidpoint(this.actor), insetRect(hitBox, 16));\n\n                console.log(this.xVelocity, this.yVelocity);\n\n                for (let i = 0; i < 12; i++) {\n                    const vel = {\n                        x: -this.xVelocity * randfloat(0.4, 0.6) + randfloat(-0.2, 0.2),\n                        y: -this.yVelocity * randfloat(0.2, 0.3) + randfloat(-0.2, 0.2),\n                    };\n\n                    this.addParticle(room, origin, vel);\n                }\n\n                this.alive = false;\n            }\n        }\n    }\n\n    applyDamage(_box: Rect, impulse: Partial<Vector>) {\n        this.hitVisualiser.up(1);\n\n        this.xVelocity = impulse?.x ?? 0;\n        this.yVelocity = impulse?.y ?? 0;\n        this.struck = true;\n    }\n\n    intersects(box: Rect) {\n        if (overlaps(box, this.actor)) {\n            return this.actor;\n        }\n    }\n}\n", "import { Solid } from '../../core/solid';\nimport { SpitBoss } from '../enemy/bosses/spit-boss';\nimport { Room, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH, type DoorsMap } from '../room';\nimport { generateRoomForDoors } from '../room-utils';\n\nexport class PitRoom extends Room {\n    getDoorwayChance() {\n        return 0.1;\n    }\n\n    static getDoorArrangement(): DoorsMap {\n        return {\n            left: {\n                high: false,\n                medium: false,\n                low: false,\n            },\n            right: {\n                high: false,\n                medium: false,\n                low: false,\n            },\n            bottom: {\n                left: false,\n                center: false,\n                right: false,\n            },\n            top: {\n                left: false,\n                center: true,\n                right: false,\n            },\n        };\n    }\n\n    static isValidAt(_x: number, _y: number) {\n        return true;\n        // return y >= 3 && x !== 0;\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { solids, blockers } = generateRoomForDoors(this.doors);\n        this.solids = solids\n            .concat(blockers)\n            .concat(\n                new Solid(320, 160, 920, 40),\n                new Solid(840, 0, 440, 200),\n                new Solid(0, 0, 80, ROOM_SCALE_HEIGHT),\n                new Solid(ROOM_SCALE_WIDTH - 80, 0, 80, ROOM_SCALE_HEIGHT),\n                new Solid(0, ROOM_SCALE_HEIGHT - 80, ROOM_SCALE_WIDTH, 80),\n                new Solid(80, 160, 240, 10, { isDroppable: true }),\n            );\n\n        this.enemies = [\n            new SpitBoss(780, ROOM_SCALE_HEIGHT - 80),\n        ];\n    }\n\n    onAllEnemiesCleared() {\n        super.onAllEnemiesCleared();\n\n        this.solids = this.solids.concat(\n            ...[320, 480].map(y =>\n                new Solid(80, y, 240, 10, { isDroppable: true }),\n            ),\n        );\n    }\n}\n", "import { Solid } from '../../core/solid';\nimport { Walker } from '../enemy/walker';\nimport { Room, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH } from '../room';\nimport { generateRoomForDoors } from '../room-utils';\n\nfunction isDefined<T>(item: T | undefined): item is T {\n    return !!item;\n}\n\nexport class TRoom extends Room {\n    getDoorwayChance() {\n        return 0;\n    }\n\n    static getDoorArrangement() {\n        return {\n            left: {\n                high: true,\n                medium: false,\n                low: false,\n            },\n            right: {\n                high: true,\n                medium: false,\n                low: false,\n            },\n            bottom: {\n                left: false,\n                center: true,\n                right: false,\n            },\n            top: {},\n        };\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { solids, blockers } = generateRoomForDoors(this.doors);\n        this.solids = solids\n            .concat(blockers)\n            .concat(\n                new Solid(0, 240, 440, ROOM_SCALE_HEIGHT - 240),\n                new Solid(840, 240, ROOM_SCALE_WIDTH - 840, ROOM_SCALE_HEIGHT - 240),\n                new Solid(440, 240, 400, 10, { isDroppable: true }),\n                new Solid(440, 380, 400, 10, { isDroppable: true }),\n                new Solid(440, 520, 400, 10, { isDroppable: true }),\n            )\n            .concat(\n                ...[\n                    this.doors.top['left'] ? new Solid(120, 120, 120, 10, { isDroppable: true }) : undefined,\n                    this.doors.top['center'] ? new Solid(580, 120, 120, 10, { isDroppable: true }) : undefined,\n                    this.doors.top['right'] ? new Solid(1040, 120, 120, 10, { isDroppable: true }) : undefined,\n                ].filter(isDefined),\n            );\n\n        this.enemies = [\n            new Walker(ROOM_SCALE_WIDTH / 4, 176),\n            new Walker(ROOM_SCALE_WIDTH * 3 / 4, 176),\n        ];\n    }\n}\n", "import { randint } from './core/math';\nimport { GhostRoom } from './room/layouts/ghost_room';\nimport { HRoom } from './room/layouts/h_room';\nimport { LRoom } from './room/layouts/l_room';\nimport { PitRoom } from './room/layouts/pit_room';\nimport { TRoom } from './room/layouts/t_room';\nimport { Room, type DoorsMap } from './room/room';\n\nconst MAP_ROOM_WIDTH = 128;\nconst MAP_ROOM_HEIGHT = 72;\nconst DEFAULT_MAP_WIDTH = 9;\nconst DEFAULT_MAP_HEIGHT = 6;\n\nconst MAP_ROOM_SCALE = 1 / 10;\n\nconst CURRENT_ROOM_BORDER = 2;\n\n/** Amount to jump canvas size up by when re-drawing. */\nconst INCREMENT_BY = 4;\n\nexport class WorldMap {\n    lastRoomIndex: { x: number; y: number };\n    map: Record<string, Room>;\n\n    x: number;\n    y: number;\n    currentIndex: string;\n\n    minX: number;\n    minY: number;\n\n    canvas: OffscreenCanvas;\n    ctx: OffscreenCanvasRenderingContext2D;\n\n    constructor() {\n        this.lastRoomIndex = { x: 0, y: 0 };\n\n        this.map = {};\n        this.x = 0;\n        this.y = 0;\n        this.currentIndex = this.index(0, 0);\n\n        this.minX = 0;\n        this.minY = 0;\n\n        const room = new Room(0, 0, 1, 1);\n\n        this.map[this.index(0, 0)] = room;\n\n        const cols = Math.max(DEFAULT_MAP_WIDTH);\n        const rows = Math.max(DEFAULT_MAP_HEIGHT);\n\n        this.canvas = new OffscreenCanvas(cols * MAP_ROOM_WIDTH, rows * MAP_ROOM_HEIGHT);\n        const ctx = this.canvas.getContext('2d');\n\n        if (!ctx) {\n            throw Error('Could not construct canvas');\n        }\n\n        this.ctx = ctx;\n\n        this.redrawWorldMap();\n    }\n\n    createNewCanvas(minX: number, maxX: number, minY: number, maxY: number) {\n        const cols = Math.max(DEFAULT_MAP_WIDTH, maxX - minX + 1 + INCREMENT_BY);\n        const rows = Math.max(DEFAULT_MAP_HEIGHT, maxY - minY + 1 + INCREMENT_BY);\n\n        this.canvas = new OffscreenCanvas(cols * MAP_ROOM_WIDTH, rows * MAP_ROOM_HEIGHT);\n\n        const ctx = this.canvas.getContext('2d');\n\n        if (!ctx) {\n            throw Error('Could not construct canvas');\n        }\n\n        this.ctx = ctx;\n    }\n\n    getNeighboringDoors(x: number, y: number) {\n        return {\n            right: { ...this.map[this.index(x + 1, y)]?.doors?.left },\n            left: { ...this.map[this.index(x - 1, y)]?.doors?.right },\n            top: { ...this.map[this.index(x, y - 1)]?.doors?.bottom },\n            bottom: { ...this.map[this.index(x, y + 1)]?.doors?.top },\n        };\n    }\n\n    generateRoomChoices(x: number, y: number, suggestedDoors: Partial<DoorsMap> = {}) {\n        const makeColor = () => `hsl(${randint(0, 360)}, 60%, 60%)`;\n\n        const cloneDoors = () => ({\n            left: { ...(suggestedDoors.left ?? {}) },\n            right: { ...(suggestedDoors.right ?? {}) },\n            top: { ...(suggestedDoors.top ?? {}) },\n            bottom: { ...(suggestedDoors.bottom ?? {}) },\n        });\n\n        const CONSTRUCTORS = [GhostRoom, HRoom, LRoom, TRoom, PitRoom];\n\n        const checkDoors = cloneDoors();\n\n        const acceptableConstructors = CONSTRUCTORS.filter(Class =>\n            Class.isValidAt(x, y) && Class.areDoorsOk(checkDoors),\n        );\n\n        /** TODO: Shuffle constructors */\n\n        /** Pad with auto-generators */\n        acceptableConstructors.push(Room, Room, Room);\n\n        const choices = [];\n\n        for (let i = 0; i < 3; i++) {\n            const RoomType = acceptableConstructors.shift();\n\n            if (!RoomType) {\n                throw new Error('Could not find enough rooms');\n            }\n\n            /** Must re-compute neighboring doors for each as otherwise each instance will be shared. */\n            choices.push(new RoomType(x, y, 1, 1, makeColor(), cloneDoors()));\n        }\n\n        return choices;\n    }\n\n    redrawWorldMap() {\n        let maxX = 0, maxY = 0;\n\n        for (const room of Object.values(this.map)) {\n            this.minX = Math.min(this.minX, room.x);\n            maxX = Math.max(maxX, room.x);\n            this.minY = Math.min(this.minY, room.y);\n            maxY = Math.max(maxY, room.y);\n        }\n\n        if (maxX - this.minX + 1 > this.canvas.width / MAP_ROOM_WIDTH || maxY - this.minY + 1 > this.canvas.height / MAP_ROOM_HEIGHT) {\n            this.createNewCanvas(this.minX, maxX, this.minY, maxY);\n        }\n\n        this.ctx.fillStyle = 'black';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        for (const room of Object.values(this.map)) {\n            this.ctx.save();\n            this.ctx.translate((room.x - this.minX) * MAP_ROOM_WIDTH, (room.y - this.minY) * MAP_ROOM_HEIGHT);\n            this.ctx.scale(MAP_ROOM_SCALE, MAP_ROOM_SCALE);\n\n            room.drawForMap(this.ctx);\n\n            this.ctx.restore();\n        }\n    }\n\n    drawMapToScreen(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number) {\n        const drawWidth = Math.min(width, this.canvas.width);\n        const drawHeight = Math.min(height, this.canvas.height);\n\n        const xOffset = (-this.minX + this.x + 1 / 2) * MAP_ROOM_WIDTH - width / 2;\n\n        ctx.drawImage(this.canvas, xOffset, 0, drawWidth, drawHeight, x, y, drawWidth, drawHeight);\n\n        ctx.strokeStyle = 'white';\n        ctx.lineWidth = CURRENT_ROOM_BORDER;\n        ctx.strokeRect(\n            -xOffset + (this.x - this.minX + 1 / 2) * MAP_ROOM_WIDTH - CURRENT_ROOM_BORDER,\n            y + this.y * MAP_ROOM_HEIGHT - CURRENT_ROOM_BORDER,\n            MAP_ROOM_WIDTH + CURRENT_ROOM_BORDER * 2,\n            MAP_ROOM_HEIGHT + CURRENT_ROOM_BORDER * 2,\n        );\n    }\n\n    index(x: number, y: number) {\n        return `${x},${y}`;\n    }\n\n    getCurrentRoom(): Room {\n        return this.map[this.currentIndex]!;\n    }\n\n    getPreviousRoom(): Room {\n        return this.map[this.index(this.lastRoomIndex.x, this.lastRoomIndex.y)]!;\n    }\n\n    hasRoom(x: number, y: number) {\n        const index = this.index(x, y);\n\n        return index in this.map;\n    }\n\n    enterRoom(x: number, y: number) {\n        this.lastRoomIndex = { x: this.x, y: this.y };\n\n        this.x = x;\n        this.y = y;\n        this.currentIndex = this.index(x, y);\n\n        this.redrawWorldMap();\n    }\n\n    addRoom(room: Room) {\n        if (this.map[this.currentIndex]) {\n            throw new Error('Adding room where we already have one!');\n        }\n\n        this.map[this.currentIndex] = room;\n\n        /** Left room */\n        this.map[this.index(this.x - 1, this.y)]?.setExternalMatchingDoorways?.({\n            right: room.doors.left,\n        });\n        /** Right room */\n        this.map[this.index(this.x + 1, this.y)]?.setExternalMatchingDoorways?.({\n            left: room.doors.right,\n        });\n        /** Top room */\n        this.map[this.index(this.x, this.y - 1)]?.setExternalMatchingDoorways?.({\n            bottom: room.doors.top,\n        });\n        /** Bottom room */\n        this.map[this.index(this.x, this.y + 1)]?.setExternalMatchingDoorways?.({\n            top: room.doors.bottom,\n        });\n\n        room.setExternalMatchingDoorways({\n            left: this.map[this.index(this.x - 1, this.y)]?.doors?.right,\n            right: this.map[this.index(this.x + 1, this.y)]?.doors?.left,\n            top: this.map[this.index(this.x, this.y - 1)]?.doors?.bottom,\n            bottom: this.map[this.index(this.x, this.y + 1)]?.doors?.top,\n        });\n\n        this.redrawWorldMap();\n    }\n}\n", "import { latch, type BooleanLatch } from './core/latch';\nimport { isPointInside, type Vector } from './core/math';\nimport { ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH, type DoorsMap, type Room } from './room/room';\nimport { WorldMap } from './worldMap';\n\nconst FRAME_DURATION = 2;\n\nconst MAP_KEY = 'Tab';\n\nconst MAP_INSET = 64;\nconst MAP_BORDER = 4;\n\nexport class CaveWorld {\n    worldMap: WorldMap;\n\n    lastFrameTime: number;\n    unprocessedTime: number;\n\n    pausedFor: 'Tab' | 'choices' | undefined;\n    choosing: boolean;\n    choices: Room[];\n\n    tabLatch: BooleanLatch;\n    mouseOverChoiceIndex: number;\n    firstTickInNewRoom: boolean;\n\n    constructor() {\n        this.worldMap = new WorldMap();\n\n        this.lastFrameTime = performance.now();\n        this.unprocessedTime = 0;\n\n        this.pausedFor = undefined;\n        this.choosing = true;\n        this.choices = [];\n\n        this.tabLatch = latch(false);\n\n        this.mouseOverChoiceIndex = -1;\n\n        this.firstTickInNewRoom = false;\n    }\n\n    /** Update loop */\n    update(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, mousePosition: Vector | undefined, keyboardState: Record<string, boolean>) {\n        this.tabLatch(\n            !!keyboardState[MAP_KEY],\n            {\n                onLock: () => {\n                    if (this.pausedFor === 'Tab') {\n                        this.lastFrameTime = performance.now();\n                        this.pausedFor = undefined;\n                    } else {\n                        if (!this.pausedFor) {\n                            this.pausedFor = 'Tab';\n                        }\n                    }\n                },\n            },\n        );\n\n        /** Choices setup */\n        if (this.pausedFor === 'choices') {\n            if (this.choices.length === 0) {\n                this.choices = this.worldMap.generateRoomChoices(this.worldMap.x, this.worldMap.y);\n            }\n\n            this.draw(ctx, canvas, mousePosition, 0);\n            this.drawMap(ctx, canvas);\n            this.drawOptions(ctx, canvas, mousePosition);\n            return;\n        } else if (this.pausedFor === 'Tab') {\n            this.draw(ctx, canvas, mousePosition, 0);\n\n            this.drawMap(ctx, canvas);\n            return;\n        }\n\n        /** Time computation */\n        const currentTime = performance.now();\n        const elapsedTime = this.firstTickInNewRoom ? 0 : Math.min(currentTime - this.lastFrameTime, 250);\n        this.lastFrameTime = currentTime;\n\n        this.firstTickInNewRoom = false;\n\n        this.unprocessedTime += elapsedTime;\n\n        while (this.unprocessedTime >= FRAME_DURATION && !this.pausedFor) {\n            this.simulateFrame(mousePosition, keyboardState);\n\n            this.unprocessedTime -= FRAME_DURATION;\n        }\n\n        if (this.pausedFor) {\n            this.unprocessedTime = 0;\n        }\n\n        const interpolationFactor = this.unprocessedTime / FRAME_DURATION;\n\n        this.draw(ctx, canvas, mousePosition, interpolationFactor);\n    }\n\n    drawMap(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) {\n        ctx.fillStyle = '#00000099';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n        ctx.fillStyle = 'white';\n        ctx.fillRect(MAP_INSET - MAP_BORDER, MAP_INSET - MAP_BORDER, canvas.height - (MAP_INSET - MAP_BORDER) * 2, canvas.height - (MAP_INSET - MAP_BORDER) * 2);\n\n        ctx.fillStyle = 'black';\n        ctx.fillRect(MAP_INSET, MAP_INSET, canvas.height - MAP_INSET * 2, canvas.height - MAP_INSET * 2);\n\n        this.worldMap.drawMapToScreen(ctx, MAP_INSET, MAP_INSET, canvas.height - MAP_INSET * 2, canvas.height - MAP_INSET * 2);\n    }\n\n    click(_canvas: HTMLCanvasElement, _mousePosition: Vector) {\n        const choosing = this.pausedFor === 'choices' && this.choices.length > 0;\n        const mousingOverValidOption = this.mouseOverChoiceIndex >= 0 && this.mouseOverChoiceIndex < this.choices.length;\n\n        if (choosing && mousingOverValidOption) {\n            const newRoom = this.choices[this.mouseOverChoiceIndex]!;\n            this.worldMap.addRoom(newRoom);\n\n            const lastRoom = this.worldMap.getPreviousRoom();\n            this.transferPlayerPosition(lastRoom, newRoom);\n\n            this.unprocessedTime = 0;\n            this.firstTickInNewRoom = true;\n\n            this.pausedFor = undefined;\n            this.choices = [];\n        }\n    }\n\n    transferPlayerPosition(lastRoom: Room, newRoom: Room) {\n        newRoom.playerState.xVelocity = lastRoom.playerState.xVelocity;\n        /** Cap player y velocity when falling room to room */\n        newRoom.playerState.yVelocity = Math.min(lastRoom.playerState.yVelocity, 0.1);\n\n        const worldX = lastRoom.playerState.actor.x + lastRoom.x * ROOM_SCALE_WIDTH;\n        const worldY = lastRoom.playerState.actor.y + lastRoom.y * ROOM_SCALE_HEIGHT;\n\n        newRoom.playerState.actor.x = worldX - newRoom.x * ROOM_SCALE_WIDTH;\n        newRoom.playerState.actor.y = worldY - newRoom.y * ROOM_SCALE_HEIGHT;\n\n        /** If falling room to room cap their new y to 1px down */\n        if (newRoom.y >= lastRoom.y + lastRoom.height) {\n            newRoom.playerState.actor.y = Math.min(newRoom.playerState.actor.y, 1);\n        } else if (newRoom.y + newRoom.height <= lastRoom.y) {\n            newRoom.playerState.yVelocity = Math.min(-1.1, newRoom.playerState.yVelocity);\n        }\n\n        newRoom.playerState.facing = lastRoom.playerState.facing;\n    }\n\n    simulateFrame(mousePosition: Vector | undefined, keyboardState: Record<string, boolean>) {\n        const room = this.worldMap.getCurrentRoom();\n        room.update(mousePosition, keyboardState, FRAME_DURATION, this.onRoomChange.bind(this));\n    }\n\n    onRoomChange(x: number, y: number, doors: Partial<DoorsMap>) {\n        if (this.worldMap.hasRoom(x, y)) {\n            this.worldMap.enterRoom(x, y);\n\n            this.transferPlayerPosition(this.worldMap.getPreviousRoom(), this.worldMap.getCurrentRoom());\n        } else {\n            this.pausedFor = 'choices';\n            this.worldMap.enterRoom(x, y);\n            this.choices = this.worldMap.generateRoomChoices(this.worldMap.x, this.worldMap.y, doors);\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, mousePosition: Vector | undefined, interpolationFactor: number) {\n        const room = this.worldMap.getCurrentRoom();\n\n        if (room) {\n            room.draw(ctx, canvas, mousePosition, interpolationFactor);\n        }\n    }\n\n    drawOptions(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, mousePosition: Vector | undefined) {\n        this.mouseOverChoiceIndex = -1;\n\n        for (let i = 0; i < this.choices.length; i++) {\n            const roomChoice = this.choices[i]!;\n\n            const left = canvas.height;\n            const right = canvas.width;\n            const middle = (left + right) / 2;\n            const height = canvas.height / this.choices.length;\n            const top = height * i;\n            const bottom = top + height;\n\n            ctx.save();\n            ctx.translate(middle, (top + bottom) / 2);\n\n            const mouseInside = mousePosition && isPointInside({\n                x: left,\n                y: top,\n                width: right - left,\n                height,\n            }, mousePosition.x, mousePosition.y);\n\n            const scaleFactor = (right - left) / ROOM_SCALE_WIDTH * 0.5;\n\n            ctx.scale(scaleFactor, scaleFactor);\n\n            if (mouseInside) {\n                this.mouseOverChoiceIndex = i;\n                ctx.scale(1.1, 1.1);\n            }\n\n            ctx.translate(-ROOM_SCALE_WIDTH / 2, -ROOM_SCALE_HEIGHT / 2);\n\n            roomChoice.drawForMap(ctx);\n\n            ctx.restore();\n        }\n    }\n}\n", "import { CaveWorld } from \"./caveWorld\";\nimport type { Vector } from \"./core/math\";\n\nfunction main() {\n    /** Page setup */\n    const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n\n    if (!canvas) {\n        console.error('Could not find canvas');\n        return;\n    }\n\n    const ctx = canvas.getContext('2d')!;\n\n    if (!ctx) {\n        console.error('');\n        throw Error('Could not set up canvas rendering context');\n    }\n\n    ctx.imageSmoothingEnabled = false;\n\n    /** Game init */\n    const caves = new CaveWorld();\n\n    /** Mouse-related event listeners */\n    let mousePosition: Vector | undefined;\n    canvas.addEventListener('mousemove', e => {\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n\n        mousePosition = { x, y };\n    });\n\n    canvas.addEventListener('mouseleave', () => {\n        mousePosition = undefined;\n    });\n\n    canvas.addEventListener('click', e => {\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n\n        mousePosition = { x, y };\n\n        caves.click(canvas, mousePosition);\n    });\n\n    /** Keyboard event listeners */\n    let keyboardState: Record<string, boolean> = {};\n    window.addEventListener('keydown', e => {\n        keyboardState[e.key] = true;\n        if (e.key === 'Tab' || e.key === ' ') {\n            e.preventDefault();\n        }\n    });\n\n    window.addEventListener('keyup', e => {\n        delete keyboardState[e.key];\n    });\n\n    window.addEventListener('blur', () => {\n        keyboardState = {};\n    });\n\n    /** Game loop */\n    function loop() {\n        caves.update(ctx, canvas, mousePosition, keyboardState);\n\n        requestAnimationFrame(loop);\n    }\n\n    loop();\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    main();\n});\n"],
  "mappings": "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",
  "names": ["latch", "initialState", "state", "newState", "onLock", "onRelease", "incDecLatch", "stepsUp", "stepsDown", "by", "lerp", "a", "b", "t", "randint", "lo", "hi", "randfloat", "overlaps", "isPointInside", "rect", "x", "y", "square", "approach", "target", "current", "step", "clamp", "clampPointWithin", "vector", "insetRect", "insetBy", "rectMidpoint", "normalize", "radius", "magnitude", "distance", "p1", "p2", "randomPerimeterPoint", "halfPerimeter", "pos", "randomPointInRect", "Solid", "x", "y", "width", "height", "config", "actors", "solids", "moveX", "moveY", "riding", "actor", "overlaps", "a", "Actor", "x", "y", "width", "height", "isDropping", "solid", "overlaps", "amount", "onCollide", "solids", "move", "sign", "collidingSolid", "droppingThroughSolids", "groundingCollider", "isPointInside", "Sprite", "src", "sprite", "Particle", "x", "y", "width", "height", "color", "vX", "vY", "lifespan", "gravity", "ctx", "frameDuration", "SWORD_SWOOSH", "Sprite", "ATTACK_HEIGHT", "ATTACK_WIDTH", "ATTACK_SCALE", "KNOCKBACK_AMOUNT", "Attack", "facing", "ctx", "relativePosition", "attackTransparency", "attackSrcX", "attackDestX", "attackDestY", "base", "basePosition", "enemy", "box", "hitBox", "BufferedThrottledInputController", "preBufferDuration", "coolDown", "activeDuration", "frameDuration", "isPressed", "onActivation", "isPressReady", "JumpController", "keyboardState", "frameDuration", "yVelocity", "isJumping", "nowGrounded", "nowJumping", "PLAYER_WIDTH", "PLAYER_HEIGHT", "SPEED", "PLAYER_X_ACCEL", "JUMP_MAGNITUDE", "ATTACK_DURATION", "ATTACK_COOLDOWN", "ATTACK_BUFFER", "LEFT_KEY", "DOWN_KEY", "RIGHT_KEY", "ATTACK_KEY", "PLAYER_SPRITE", "Sprite", "getImageCoordinates", "attacking", "facing", "hasShield", "x", "y", "PlayerState", "Actor", "JumpController", "BufferedThrottledInputController", "ctx", "_canvas", "_mousePosition", "interpolationFactor", "xInterp", "lerp", "yInterp", "isAttacking", "attackTransparency", "square", "attack", "sx", "sy", "keyboardState", "frameDuration", "room", "solids", "enemies", "Attack", "enemy", "xInput", "xVelocity", "approach", "yAcceleration", "isJumping", "i", "relX", "randfloat", "Particle", "isGrounded", "X_SPEED", "X_ACCEL", "Y_ACCEL", "GHOSTY_SPRITE", "Sprite", "ENEMY_WIDTH", "ENEMY_HEIGHT", "VISUAL_SCALE", "Enemy", "x", "y", "Actor", "incDecLatch", "ctx", "frameDuration", "room", "playerPosition", "_room", "myMidpoint", "approach", "_box", "impulse", "box", "overlaps", "WALKING_SPEED", "WALKING_ACCEL", "GRAVITY", "Walker", "Enemy", "x", "y", "frameDuration", "room", "_playerPosition", "standingSolid", "solid", "overlaps", "approach", "groundSolid", "spaceSolid", "box", "impulse", "LOOP_DUR", "MovingPlatform", "x", "y", "width", "height", "Solid", "frameDuration", "actors", "solids", "timeInCycle", "shouldBeInCycle", "createSolid", "args", "config", "x", "y", "width", "height", "Solid", "getGapNames", "gapMap", "names", "key", "a", "b", "GAPS", "getDoorBlockingSolids", "doors", "solids", "name", "top", "bottom", "WALL_THICKNESS", "ROOM_SCALE_WIDTH", "left", "right", "ROOM_SCALE_HEIGHT", "generateRoomForDoors", "blockers", "gapLeft", "GAP_SIZE", "gapRight", "topStarts", "topEnds", "index", "bottomStarts", "bottomEnds", "leftStarts", "leftEnds", "rightStarts", "rightEnds", "ladders", "blocker", "WALL_THICKNESS", "ROOM_SCALE_WIDTH", "ROOM_SCALE_HEIGHT", "GAP_SIZE", "GAPS", "VERTICAL_DOOR_KEYS", "HORIZONTAL_DOOR_KEYS", "Room", "_Room", "_x", "_y", "setDoors", "arr", "HORIZONTAL_DOOR_KEYS", "key", "VERTICAL_DOOR_KEYS", "x", "y", "width", "height", "color", "PlayerState", "ROOM_SCALE_WIDTH", "ROOM_SCALE_HEIGHT", "odds", "solids", "blockers", "ladders", "generateRoomForDoors", "MovingPlatform", "i", "Enemy", "Walker", "ctx", "canvas", "mousePosition", "interpolationFactor", "solid", "particle", "enemy", "keyboardState", "frameDuration", "onRoomChange", "overlaps", "interactive", "playerMidpoint", "doors", "relevantGap", "gap", "GAPS", "doorsToBlock", "_face", "face", "_doorway", "doorway", "getDoorBlockingSolids", "mapCtx", "GHOST_WIDTH", "GHOST_COLLIDER_WIDTH", "GHOST_BOSS_SPEED", "GhostBossSprite", "Sprite", "INSIDE_COLLIDER", "ROOM_SCALE_WIDTH", "ROOM_SCALE_HEIGHT", "SCREEN_COLLIDER", "GhostBoss", "x", "y", "incDecLatch", "frameDuration", "room", "playerPosition", "isPointInside", "fleeSpeedMod", "overlaps", "speedMod", "pPos", "randomPointInRect", "RADIUS", "Particle", "startingPoint", "rectMidpoint", "direction", "speed", "normalize", "distance", "randomPerimeterPoint", "px", "py", "pos", "ctx", "OFFSET", "_box", "box", "GhostRoom", "Room", "solids", "blockers", "generateRoomForDoors", "y", "Solid", "ROOM_SCALE_WIDTH", "GhostBoss", "ROOM_SCALE_HEIGHT", "HRoom", "Room", "_x", "y", "blockers", "generateRoomForDoors", "Solid", "ROOM_SCALE_HEIGHT", "ROOM_SCALE_WIDTH", "LRoom", "Room", "_x", "y", "solids", "blockers", "generateRoomForDoors", "Solid", "ROOM_SCALE_WIDTH", "SPITBOSS_BASE_WIDTH", "SPITBOSS_BASE_HEIGHT", "SPITBOSS_HEAD_WIDTH", "SPITBOSS_HEAD_HEIGHT", "GRAVITY", "SpitBossHeadSprite", "Sprite", "SpitBossBaseSprite", "SpitBossSpitSprite", "SpitBoss", "x", "y", "incDecLatch", "ctx", "BASE_WIDTH_OFF", "BASE_HEIGHT_OFF", "HEAD_OFF", "frameDuration", "room", "playerPosition", "newProjectiles", "aboveCollider", "maxY", "solid", "overlaps", "startingY", "acceptablePeak", "SPITBALL_RADIUS", "maxYVelocity", "yVelocity", "randfloat", "determinant", "timeToPlayerY", "xVelocity", "numToThrow", "randint", "SpitBoss_Spit", "box", "xVel", "yVel", "parent", "Actor", "origin", "velocity", "Particle", "_playerPosition", "wallHit", "drn", "i", "vel", "hitBox", "clampPointWithin", "rectMidpoint", "insetRect", "_box", "impulse", "PitRoom", "Room", "_x", "_y", "solids", "blockers", "generateRoomForDoors", "Solid", "ROOM_SCALE_HEIGHT", "ROOM_SCALE_WIDTH", "SpitBoss", "y", "isDefined", "item", "TRoom", "Room", "solids", "blockers", "generateRoomForDoors", "Solid", "ROOM_SCALE_HEIGHT", "ROOM_SCALE_WIDTH", "Walker", "MAP_ROOM_WIDTH", "MAP_ROOM_HEIGHT", "DEFAULT_MAP_WIDTH", "DEFAULT_MAP_HEIGHT", "MAP_ROOM_SCALE", "CURRENT_ROOM_BORDER", "INCREMENT_BY", "WorldMap", "room", "Room", "cols", "rows", "ctx", "minX", "maxX", "minY", "maxY", "x", "y", "suggestedDoors", "makeColor", "randint", "cloneDoors", "CONSTRUCTORS", "GhostRoom", "HRoom", "LRoom", "TRoom", "PitRoom", "checkDoors", "acceptableConstructors", "Class", "choices", "i", "RoomType", "width", "height", "drawWidth", "drawHeight", "xOffset", "FRAME_DURATION", "MAP_KEY", "MAP_INSET", "MAP_BORDER", "CaveWorld", "WorldMap", "latch", "ctx", "canvas", "mousePosition", "keyboardState", "currentTime", "elapsedTime", "interpolationFactor", "_canvas", "_mousePosition", "choosing", "mousingOverValidOption", "newRoom", "lastRoom", "worldX", "ROOM_SCALE_WIDTH", "worldY", "ROOM_SCALE_HEIGHT", "x", "y", "doors", "room", "i", "roomChoice", "left", "right", "middle", "height", "top", "bottom", "mouseInside", "isPointInside", "scaleFactor", "main", "canvas", "ctx", "caves", "CaveWorld", "mousePosition", "e", "rect", "x", "y", "keyboardState", "loop"]
}
