{
  "version": 3,
  "sources": ["../js/core/latch.ts", "../js/core/math.ts", "../js/core/solid.ts", "../js/core/actor.ts", "../js/core/sprite.ts", "../js/core/types.ts", "../js/player/jumpController.ts", "../js/ecs/ecs.ts", "../js/room/ecs/solidSystem.ts", "../js/room/ecs/playerSystem.ts", "../js/room/ecs/enemySystem.ts", "../js/room/ecs/movingPlatformSystem.ts", "../js/room/ecs/rectArtSystem.ts", "../js/room/enemy/enemy.ts", "../js/room/enemy/walker.ts", "../js/room/room-utils.ts", "../js/room/room.ts", "../js/room/particle.ts", "../js/room/enemy/bosses/ghost-boss.ts", "../js/room/layouts/ghost_room.ts", "../js/room/layouts/h_room.ts", "../js/room/layouts/l_room.ts", "../js/room/enemy/bosses/spit-boss.ts", "../js/room/layouts/pit_room.ts", "../js/room/layouts/t_room.ts", "../js/worldMap.ts", "../js/caveWorld.ts", "../js/main.ts"],
  "sourcesContent": ["export type BooleanLatch = (newState: boolean, handlers: { onLock?: () => void; onRelease?: () => void }) => void;\n\nexport const latch = (initialState: boolean): BooleanLatch => {\n    let state = initialState;\n\n    return (newState, { onLock, onRelease }) => {\n        if (newState === state) {\n            return;\n        }\n\n        state = newState;\n        if (newState) {\n            if (onLock) onLock();\n        } else {\n            if (onRelease) onRelease();\n        }\n    };\n};\n\nexport type IncDecLatch = {\n    up: (by?: number) => void;\n    down: (by?: number) => void;\n    check: () => number;\n};\n\nexport const incDecLatch = (stepsUp: number, stepsDown: number): IncDecLatch => {\n    let state = 0;\n\n    return {\n        up(by = 1) {\n            state = Math.min(1, state + by / stepsUp);\n        },\n        down(by = 1) {\n            state = Math.max(0, state - by / stepsDown);\n        },\n        check() {\n            return state;\n        },\n    };\n};\n", "export function lerp(a: number, b: number, t: number) {\n    return (1 - t) * a + t * b;\n}\n\nexport function randint(lo: number, hi: number) {\n    return Math.floor((hi - lo) * Math.random());\n}\n\nexport function randfloat(lo: number, hi: number) {\n    return lo + Math.random() * (hi - lo);\n}\n\nexport type Vector = {\n    x: number;\n    y: number;\n};\n\nexport type Rect = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n};\n\nexport function overlaps(a: Rect, b: Rect) {\n    if (a.x >= b.x + b.width || b.x >= a.x + a.width) {\n        return false;\n    }\n\n    if (a.y >= b.y + b.height || b.y >= a.y + a.height) {\n        return false;\n    }\n\n    return true;\n}\n\nexport function isPointInside(rect: Rect, x: number, y: number) {\n    return rect.x <= x && x < rect.x + rect.width && rect.y <= y && y < rect.y + rect.height;\n}\n\nexport function square(x: number) {\n    return x * x;\n}\n\nexport function approach(target: number, current: number, step: number) {\n    if (target > current) {\n        return Math.min(target, current + step);\n    } else if (target < current) {\n        return Math.max(target, current - step);\n    } else {\n        return target;\n    }\n}\n\nexport function clamp(x: number, lo: number, hi: number) {\n    return Math.max(lo, Math.min(x, hi));\n}\n\nexport function clampPointWithin(vector: Vector, rect: Rect) {\n    return {\n        x: clamp(vector.x, rect.x, rect.x + rect.width),\n        y: clamp(vector.y, rect.y, rect.y + rect.height),\n    };\n}\n\nexport function insetRect(rect: Rect, insetBy: number): Rect {\n    return {\n        x: rect.x + insetBy,\n        y: rect.y + insetBy,\n        width: rect.width - 2 * insetBy,\n        height: rect.height - 2 * insetBy,\n    };\n}\n\nexport function rectMidpoint(rect: Rect): Vector {\n    return {\n        x: rect.x + rect.width / 2,\n        y: rect.y + rect.height / 2,\n    };\n}\n\nexport function normalize(vector: Vector, radius: number): Vector {\n    const magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n\n    return {\n        x: vector.x * radius / magnitude,\n        y: vector.y * radius / magnitude,\n    };\n}\n\nexport function distance(p1: Vector, p2: Vector) {\n    return Math.sqrt(square(p1.x - p2.x) + square(p1.y - p2.y));\n}\n\nexport function randomPerimeterPoint(rect: Rect): Vector {\n    const halfPerimeter = rect.width + rect.height;\n    const pos = randfloat(0, halfPerimeter);\n\n    if (pos < rect.width) {\n        return {\n            x: rect.x + pos,\n            y: randint(0, 2) ? rect.y : rect.y + rect.height,\n        };\n    } else {\n        return {\n            x: randint(0, 2) ? rect.x : rect.x + rect.width,\n            y: rect.y + (pos - rect.width),\n        };\n    }\n}\n\nexport function randomPointInRect(rect: Rect): Vector {\n    return {\n        x: rect.x + randfloat(0, rect.width),\n        y: rect.y + randfloat(0, rect.height),\n    };\n}\n", "import type { Component } from '../ecs/ecs';\n\nimport type { Actor } from './actor';\nimport { overlaps } from './math';\n\nexport type SolidConfig = {\n    isDroppable?: boolean;\n};\n\nexport class Solid implements Component {\n    x: number;\n    y: number;\n    height: number;\n    width: number;\n\n    isCollidable: boolean;\n    isDroppable: boolean;\n    color: string | undefined;\n\n    xRemainder: number;\n    yRemainder: number;\n\n    blocker: boolean;\n\n    constructor(x: number, y: number, width: number, height: number, config: SolidConfig = {}) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        this.isCollidable = true;\n        this.isDroppable = config.isDroppable ?? false;\n        this.blocker = false;\n\n        this.xRemainder = 0;\n        this.yRemainder = 0;\n    }\n\n    move(x: number, y: number, actors: Actor[], solids: Solid[]) {\n        this.xRemainder += x;\n        this.yRemainder += y;\n\n        let moveX = Math.round(this.xRemainder);\n        let moveY = Math.round(this.yRemainder);\n\n        if (moveX !== 0 || moveY !== 0) {\n            const riding = actors.filter(actor => actor.isRiding(this));\n\n            this.isCollidable = false;\n\n            if (moveX !== 0) {\n                this.xRemainder -= moveX;\n                this.x += moveX;\n\n                if (moveX > 0) {\n                    for (const actor of actors) {\n                        if (overlaps(this, actor)) {\n                            /** Push right */\n                            actor.moveX(this.x + this.width - actor.x, actor.squish, solids);\n                        } else if (riding.some(a => a === actor)) {\n                            /** Carry right */\n                            actor.moveX(moveX, () => {}, solids);\n                        }\n                    }\n                } else if (moveX < 0) {\n                    for (const actor of actors) {\n                        if (overlaps(this, actor)) {\n                            /** Push left */\n                            actor.moveX(this.x - (actor.x + actor.width), actor.squish, solids);\n                        } else if (riding.some(a => a === actor)) {\n                            /** Carry left */\n                            actor.moveX(moveX, () => {}, solids);\n                        }\n                    }\n                }\n            }\n\n            this.isCollidable = true;\n        }\n    }\n}\n", "import type { Component } from '../ecs/ecs';\n\nimport { overlaps } from './math';\nimport { Solid } from './solid';\n\nexport class Actor implements Component {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n\n    private xRemainder: number;\n    private yRemainder: number;\n\n    isDropping: boolean;\n    droppingSet: Set<any>;\n    grounded: boolean;\n\n    isNonPhysical: boolean;\n\n    constructor(x: number, y: number, width: number, height: number) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        this.xRemainder = 0;\n        this.yRemainder = 0;\n\n        this.isDropping = false;\n        this.droppingSet = new Set();\n\n        this.grounded = false;\n\n        this.isNonPhysical = false;\n    }\n\n    setDropping(isDropping: boolean | undefined) {\n        this.isDropping = !!isDropping;\n\n        this.droppingSet = new Set(Array.from(this.droppingSet).filter(solid => overlaps(this, solid)));\n    }\n\n    moveX(amount: number, onCollide: (solid: Solid) => void, solids: Solid[]) {\n        this.xRemainder += amount;\n        let move = Math.round(this.xRemainder);\n\n        if (move !== 0) {\n            this.xRemainder -= move;\n            const sign = move > 0 ? 1 : -1;\n\n            while (move !== 0) {\n                this.x += sign;\n                move -= sign;\n\n                /** Backtrack one step on collision and return */\n                const { collidingSolid, droppingThroughSolids } = this.collideAt(solids);\n\n                /** If entering a droppable solid horizontally, you fall through it */\n                droppingThroughSolids.forEach(solid => {\n                    this.droppingSet.add(solid);\n                });\n\n                if (collidingSolid) {\n                    this.x -= sign;\n                    onCollide(collidingSolid);\n                    break;\n                }\n            }\n        }\n    }\n\n    moveY(amount: number, onCollide: (solid: Solid) => void, solids: Solid[]) {\n        this.yRemainder += amount;\n        let move = Math.round(this.yRemainder);\n\n        if (move !== 0) {\n            this.yRemainder -= move;\n            const sign = move > 0 ? 1 : -1;\n\n            /** Process leftovers if any */\n            while (move !== 0) {\n                this.y += sign;\n                move -= sign;\n\n                /** Backtrack one step on collision and return */\n                let { collidingSolid, droppingThroughSolids } = this.collideAt(solids);\n\n                /** If moving up or dropping then just mark solids we are dropping through */\n                if ((sign < 0 || this.isDropping) && droppingThroughSolids.length > 0) {\n                    droppingThroughSolids.forEach(solid => this.droppingSet.add(solid));\n                } else if (droppingThroughSolids.length > 0) {\n                    /** We are falling and not dropping through platforms */\n                    collidingSolid = droppingThroughSolids[0];\n                }\n\n                if (collidingSolid) {\n                    this.y -= sign;\n                    onCollide(collidingSolid);\n                    break;\n                }\n            }\n        }\n    }\n\n    isGrounded(solids: Solid[]) {\n        const groundingCollider = { x: this.x, y: this.y + this.height, width: this.width, height: 1 };\n\n        const groundingSolid = solids.find(solid => {\n            if (this.droppingSet.has(solid)) {\n                return false;\n            }\n\n            if (this.isDropping && solid.isDroppable) {\n                return false;\n            }\n\n            return overlaps(groundingCollider, solid);\n        });\n\n        this.grounded = !!groundingSolid;\n\n        return this.grounded;\n    }\n\n    collideAt(solids: Solid[]) {\n        const droppingThroughSolids: Solid[] = [];\n\n        const collidingSolid = solids.find(solid => {\n            if (!solid.isCollidable) {\n                return false;\n            }\n\n            const overlapping = overlaps(this, solid);\n\n            if (!overlapping) {\n                return false;\n            }\n\n            if (solid.isDroppable) {\n                if (!this.droppingSet.has(solid)) {\n                    droppingThroughSolids.push(solid);\n                } else {\n                    // return true;\n                }\n                return false;\n            }\n\n            return true;\n        });\n\n        return { collidingSolid, droppingThroughSolids };\n    }\n\n    isRiding(solid: Solid) {\n        return overlaps(solid, { x: this.x, y: this.y + this.height, width: this.width, height: 1 });\n    }\n\n    squish() {\n        console.log('Squish');\n    }\n\n    getMidpoint() {\n        return {\n            x: this.x + this.width / 2,\n            y: this.y + this.height / 2,\n        };\n    }\n}\n", "export const Sprite = (src: string) => {\n    const sprite = new Image();\n    sprite.src = src;\n\n    return sprite;\n};\n", "export function isDefined<T>(item: T | null | undefined): item is T {\n    return item !== null && item !== undefined;\n}\n", "const GRAVITY = 2.5 / 1000;\nconst HIGH_GRAVITY = 6 / 1000;\n\nconst Y_VELOCITY_CUTOFF = -0.5;\n\n/** Physics utils */\nconst COYOTE_DURATION = 100;\n\nexport const JUMP_KEY = ' ';\n\nexport class JumpController {\n    isGrounded: boolean;\n    coyoteTime: number;\n    timeSinceJumpPress: number;\n    isJumpKeyDown: boolean;\n    stillHoldingJump: boolean;\n\n    constructor() {\n        this.isGrounded = false;\n        this.coyoteTime = 0;\n        this.timeSinceJumpPress = COYOTE_DURATION * 2;\n        this.isJumpKeyDown = false;\n        this.stillHoldingJump = false;\n    }\n\n    update(keyboardState: Record<string, boolean>, frameDuration: number, yVelocity: number) {\n        this.coyoteTime -= frameDuration;\n\n        if (keyboardState[JUMP_KEY]) {\n            if (this.isJumpKeyDown) {\n                this.timeSinceJumpPress += frameDuration;\n            } else {\n                this.isJumpKeyDown = true;\n                this.timeSinceJumpPress = 0;\n            }\n        } else {\n            this.stillHoldingJump = false;\n            this.isJumpKeyDown = false;\n            this.timeSinceJumpPress = COYOTE_DURATION * 2;\n        }\n\n        const isJumpDesired = this.isJumpKeyDown && this.timeSinceJumpPress < COYOTE_DURATION;\n\n        const isJumping = isJumpDesired && (this.isGrounded || this.coyoteTime > 0);\n\n        if (isJumping) {\n            this.stillHoldingJump = true;\n            this.timeSinceJumpPress = COYOTE_DURATION * 2;\n            this.coyoteTime = 0;\n        }\n\n        return { isJumping, yAcceleration: this.getGravity(yVelocity) };\n    }\n\n    getGravity(yVelocity: number) {\n        if (yVelocity > Y_VELOCITY_CUTOFF || !this.stillHoldingJump) {\n            return HIGH_GRAVITY;\n        }\n\n        return GRAVITY;\n    }\n\n    groundedCheck(nowGrounded: boolean, nowJumping: boolean) {\n        if (this.isGrounded && !nowGrounded && !nowJumping) {\n            this.coyoteTime = COYOTE_DURATION;\n        } else if (nowGrounded) {\n            this.coyoteTime = 0;\n        }\n\n        this.isGrounded = nowGrounded;\n    }\n}\n", "import type { Vector } from '../core/math';\n\nexport type KeyboardState = Record<string, boolean>;\n\nexport type UpdateArgs = {\n    mousePosition: Vector | undefined;\n    keyboardState: KeyboardState;\n    frameDuration: number;\n};\n\nexport type Entity = number;\n\nexport abstract class Component { }\n\nexport abstract class System {\n    abstract componentSet: Set<Function>;\n\n    abstract update(entities: Set<Entity>, args: UpdateArgs): void;\n\n    abstract draw?(entities: Set<Entity>, ctx: CanvasRenderingContext2D): void;\n\n    ecs!: ECS;\n}\n\nexport type ComponentClass<T extends Component> = new (...args: any[]) => T;\n\nexport class ComponentContainer {\n    private map = new Map<Function, Component>();\n\n    add(component: Component): void {\n        this.map.set(component.constructor, component);\n    }\n\n    get<T extends Component>(componentClass: ComponentClass<T>): T {\n        return this.map.get(componentClass) as T;\n    }\n\n    has(componentClass: Function): boolean {\n        return this.map.has(componentClass);\n    }\n\n    delete(componentClass: Function) {\n        this.map.delete(componentClass);\n    }\n}\n\nexport class ECS {\n    private entities = new Map<Entity, ComponentContainer>();\n    private systems = new Map<System, Set<Entity>>();\n\n    private nextEntityId = 0;\n    private entitiesToDelete = new Array<Entity>();\n\n    addEntity(): Entity {\n        const entity = this.nextEntityId;\n        this.nextEntityId++;\n        this.entities.set(entity, new ComponentContainer());\n        return entity;\n    }\n\n    removeEntity(entity: Entity) {\n        this.entitiesToDelete.push(entity);\n    }\n\n    addComponent(entity: Entity, component: Component) {\n        const container = this.entities.get(entity);\n\n        if (container) {\n            container.add(component);\n            this.checkEntitySystemMemberships(entity);\n        }\n    }\n\n    getComponents(entity: Entity): ComponentContainer {\n        const e = this.entities.get(entity);\n\n        if (!e) {\n            throw new Error('Could not find requested entity');\n        }\n\n        return e;\n    }\n\n    removeComponent(entity: Entity, componentClass: Function) {\n        const container = this.entities.get(entity);\n\n        if (container) {\n            container.delete(componentClass);\n            this.checkEntitySystemMemberships(entity);\n        }\n    }\n\n    addSystem(system: System) {\n        system.ecs = this;\n\n        this.systems.set(system, new Set());\n        for (const entity of this.entities.keys()) {\n            this.checkEntitySystemMembership(entity, system);\n        }\n    }\n\n    querySystem(systemClass: Function): Set<Entity> | undefined {\n        return Array.from(this.systems.entries()).find(([system, entities]) => {\n            return system instanceof systemClass;\n        })?.[1];\n    }\n\n    resolveEntities<T extends Component>(entities: Set<Entity> | undefined, componentClass: ComponentClass<T>): T[] {\n        if (!entities) {\n            return [];\n        }\n\n        return Array.from(entities.values()).map(e => this.getComponents(e)).map(c => c.get(componentClass));\n    }\n\n    removeSystem(system: System) {\n        this.systems.delete(system);\n    }\n\n    update(args: UpdateArgs) {\n        this.systems.entries().forEach(([system, entities]) => {\n            system.update(entities, args);\n        });\n\n        this.entitiesToDelete.forEach(entity => {\n            this.deleteEntity(entity);\n        });\n\n        this.entitiesToDelete = [];\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        this.systems.entries().forEach(([system, entities]) => {\n            system.draw?.(entities, ctx);\n        });\n    }\n\n    private deleteEntity(entity: Entity) {\n        this.entities.delete(entity);\n        this.systems.values().forEach(systemSet => {\n            systemSet.delete(entity);\n        });\n    }\n\n    private checkEntitySystemMemberships(entity: Entity) {\n        for (const system of this.systems.keys()) {\n            this.checkEntitySystemMembership(entity, system);\n        }\n    }\n\n    private checkEntitySystemMembership(entity: Entity, system: System) {\n        const componentContainer = this.entities.get(entity);\n        const systemSet = this.systems.get(system);\n\n        if (!componentContainer || !systemSet) {\n            return;\n        }\n\n        if (Array.from(system.componentSet).every(componentClass => componentContainer.has(componentClass))) {\n            systemSet.add(entity);\n        } else {\n            systemSet.delete(entity);\n        }\n    }\n}\n", "import { Actor } from '../../core/actor';\nimport { overlaps, type Vector } from '../../core/math';\nimport { Solid } from '../../core/solid';\nimport { Component, ECS, System, type Entity, type UpdateArgs } from '../../ecs/ecs';\nimport { PlayerSystem } from './playerSystem';\n\nexport class Velocity implements Component {\n    velocity: Vector;\n\n    constructor(vel: Vector) {\n        this.velocity = vel;\n    }\n}\n\nexport class SolidSystem implements System {\n    componentSet = new Set([Solid]);\n\n    ecs!: ECS;\n\n    state: 'pre-lock' | 'locked' | 'cleared' = 'pre-lock'\n\n    update(entities: Set<Entity>) {\n        switch (this.state) {\n            case 'pre-lock':\n                const players = this.ecs.resolveEntities(this.ecs.querySystem(PlayerSystem), Actor);\n                const blockers = this.ecs.resolveEntities(entities, Solid)\n                    .filter(solid => solid.blocker);\n\n                /** Check if player is still overlapping any blocker. */\n                if (blockers.some(blocker => players.some(player => overlaps(blocker, player)))) {\n                    return;\n                }\n\n                blockers.forEach(blocker => { blocker.isCollidable = true });\n                this.state = 'locked';\n                return;\n            case 'locked':\n                /** No enemy system to query right now. */\n                return;\n            case 'cleared':\n                return;\n        }\n    }\n}\n\nexport class ActorSystem implements System {\n    componentSet = new Set([Actor]);\n\n    ecs!: ECS;\n\n    update(entities: Set<Entity>, { frameDuration }: UpdateArgs) {\n        const actorEntities = Array.from(entities).map(a => this.ecs.getComponents(a));\n        const solids = this.ecs.resolveEntities(this.ecs.querySystem(SolidSystem), Solid);\n\n        actorEntities.forEach(actorEntity => {\n            const actor = actorEntity.get(Actor);\n            const colliders = actor.isNonPhysical ? [] : solids;\n\n            if (actorEntity.has(Velocity)) {\n                const v = actorEntity.get(Velocity).velocity;\n                actor.moveX(v.x * frameDuration, () => { }, colliders);\n                actor.moveY(v.y * frameDuration, () => {\n                    v.y = 0;\n                }, colliders);\n            }\n\n            actor.isGrounded(solids);\n        });\n    }\n}\n", "import { Actor } from '../../core/actor';\nimport { approach } from '../../core/math';\nimport { Sprite } from '../../core/sprite';\nimport { isDefined } from '../../core/types';\nimport type { Component, ECS, Entity, System, UpdateArgs } from '../../ecs/ecs';\nimport type { BufferedThrottledInputController } from '../../player/inputController';\nimport { JumpController } from '../../player/jumpController';\n\nimport { Velocity } from './solidSystem';\n\nconst LEFT_KEY = 'a';\nconst DOWN_KEY = 's';\nconst RIGHT_KEY = 'd';\nconst ATTACK_KEY = 'j';\n\n/** Player physics details */\nconst SPRITE_WIDTH = 28;\nconst SPRITE_HEIGHT = 36;\n\nconst PLAYER_WIDTH = 56;\nconst PLAYER_HEIGHT = 72;\n\n/** Player speed per millisecond */\nconst SPEED = 450 / 1000;\nconst PLAYER_X_ACCEL = 2.5 / 1000;\nconst JUMP_MAGNITUDE = 1;\n\nconst PLAYER_SPRITE = Sprite('./img/sword_man.png');\n\nconst getImageCoordinates = (attacking: boolean, facing: 'left' | 'right', hasShield: boolean) => {\n    let x = 0, y = 0;\n    if (facing === 'right') {\n        x += SPRITE_WIDTH;\n    }\n    if (attacking) {\n        y += SPRITE_HEIGHT;\n    }\n    if (hasShield) {\n        x += SPRITE_WIDTH * 2;\n    }\n\n    return { x, y };\n};\n\nexport class PlayerComponent implements Component {\n    facing: 'left' | 'right';\n\n    jumpController: JumpController;\n    // attackController: BufferedThrottledInputController;\n\n    constructor() {\n        this.facing = 'left';\n        this.jumpController = new JumpController();\n    }\n}\n\nexport class PlayerSystem implements System {\n    componentSet = new Set([PlayerComponent, Actor, Velocity]);\n\n    ecs!: ECS;\n\n    update(entities: Set<Entity>, { frameDuration, keyboardState }: UpdateArgs) {\n        entities.values().map(e => this.ecs.getComponents(e)).filter(isDefined).forEach(e => {\n            const actor = e.get(Actor);\n            const velocity = e.get(Velocity).velocity;\n            const playerComponent = e.get(PlayerComponent);\n\n            const xInput = (keyboardState[RIGHT_KEY] ? 1 : 0) - (keyboardState[LEFT_KEY] ? 1 : 0);\n            velocity.x = approach(xInput * SPEED, velocity.x, PLAYER_X_ACCEL * frameDuration);\n\n            const { yAcceleration, isJumping } = playerComponent.jumpController.update(keyboardState, frameDuration, velocity.y);\n\n            velocity.y += yAcceleration * frameDuration;\n\n            if (isJumping) {\n                // Add particles\n                velocity.y = -JUMP_MAGNITUDE;\n            }\n\n            if (xInput > 0) {\n                playerComponent.facing = 'right';\n            } else if (xInput < 0) {\n                playerComponent.facing = 'left';\n            }\n\n            actor.setDropping(keyboardState[DOWN_KEY]);\n\n            playerComponent.jumpController.groundedCheck(actor.grounded, isJumping);\n        });\n    }\n\n    draw(entities: Set<Entity>, ctx: CanvasRenderingContext2D) {\n        entities.values().map(e => this.ecs.getComponents(e)).filter(isDefined).forEach(e => {\n            const actor = e.get(Actor);\n            const playerComponent = e.get(PlayerComponent);\n\n            const isAttacking = false;\n            // Draw attack also\n\n            const { x: sx, y: sy } = getImageCoordinates(isAttacking, playerComponent.facing, true);\n            ctx.drawImage(PLAYER_SPRITE, sx, sy, SPRITE_WIDTH, SPRITE_HEIGHT, actor.x, actor.y, actor.width, actor.height);\n        });\n    }\n}\n\nexport const createPlayer = (ecs: ECS, x: number, y: number): Entity => {\n    const player = ecs.addEntity();\n    ecs.addComponent(player, new PlayerComponent());\n    ecs.addComponent(player, new Actor(x, y, PLAYER_WIDTH, PLAYER_HEIGHT));\n    ecs.addComponent(player, new Velocity({ x: 0, y: 0 }));\n\n    return player;\n};\n", "import { Actor } from '../../core/actor';\nimport { incDecLatch, type IncDecLatch } from '../../core/latch';\nimport { approach, distance, rectMidpoint, type Vector } from '../../core/math';\nimport { Sprite } from '../../core/sprite';\nimport type { Component, ECS, Entity, System, UpdateArgs } from '../../ecs/ecs';\n\nimport { PlayerSystem } from './playerSystem';\nimport { Velocity } from './solidSystem';\n\nconst X_SPEED = 300 / 1000;\nconst X_ACCEL = 1 / 1000;\nconst Y_ACCEL = 2 / 1000;\n\nconst GHOSTY_SPRITE = Sprite('./img/ghosty.png');\n\nconst SPRITE_WIDTH = 24;\nconst SPRITE_HEIGHT = 32;\nconst ENEMY_WIDTH = 48;\nconst ENEMY_HEIGHT = 64;\n\nexport class EnemyComponent implements Component {\n    hp: number;\n\n    facing: 'left' | 'right';\n\n    isNonPhysical: boolean;\n\n    hurtViz: IncDecLatch;\n\n    constructor() {\n        this.hp = 3;\n        this.facing = 'left';\n        this.isNonPhysical = true;\n        this.hurtViz = incDecLatch(1, 250);\n    }\n}\n\nexport class EnemySystem implements System {\n    componentSet = new Set([EnemyComponent, Actor, Velocity]);\n\n    ecs!: ECS;\n\n    update(entities: Set<Entity>, { frameDuration }: UpdateArgs) {\n        const players = this.ecs.resolveEntities(this.ecs.querySystem(PlayerSystem), Actor)\n            .map(p => rectMidpoint(p));\n\n        const enemies = Array.from(entities.values().map(e => this.ecs.getComponents(e)));\n\n        enemies.forEach(enemy => {\n            const enemyC = enemy.get(EnemyComponent);\n            const myMid = rectMidpoint(enemy.get(Actor));\n            const v = enemy.get(Velocity).velocity;\n\n            const [target] = players.reduce<[Vector | undefined, number]>(([point, bestDist], target) => {\n                const thisDist = distance(myMid, target);\n\n                if (thisDist < bestDist) {\n                    return [target, thisDist];\n                }\n\n                return [point, bestDist];\n            }, [undefined, Infinity]);\n\n            if (target) {\n                if (target.x < myMid.x) {\n                    v.x = approach(-X_SPEED, v.x, X_ACCEL * frameDuration);\n                    enemyC.facing = 'left';\n                } else {\n                    v.x = approach(X_SPEED, v.x, X_ACCEL * frameDuration);\n                    enemyC.facing = 'right';\n                }\n\n                v.y = approach(target.y < myMid.y ? -X_SPEED : X_SPEED, v.y, Y_ACCEL * frameDuration);\n            }\n        });\n    }\n\n    draw(entities: Set<Entity>, ctx: CanvasRenderingContext2D) {\n        entities.values().forEach(e => {\n            const enemy = this.ecs.getComponents(e);\n            const enemyC = enemy.get(EnemyComponent);\n            const actor = enemy.get(Actor);\n\n            ctx.drawImage(\n                GHOSTY_SPRITE,\n                enemyC.facing === 'left' ? 0 : SPRITE_WIDTH,\n                0,\n                SPRITE_WIDTH,\n                SPRITE_HEIGHT,\n                actor.x,\n                actor.y,\n                actor.width,\n                actor.height,\n            );\n        });\n    }\n}\n\nexport const createEnemy = (ecs: ECS, x: number, y: number): Entity => {\n    const enemy = ecs.addEntity();\n    ecs.addComponent(enemy, new EnemyComponent());\n\n    const actor = new Actor(x, y, ENEMY_WIDTH, ENEMY_HEIGHT);\n    actor.isNonPhysical = true;\n\n    ecs.addComponent(enemy, actor);\n    ecs.addComponent(enemy, new Velocity({ x: 0, y: 0 }));\n\n    return enemy;\n};\n", "import { Actor } from '../../core/actor';\nimport { lerp, type Vector } from '../../core/math';\nimport { Solid } from '../../core/solid';\nimport type { Component, ECS, Entity, System, UpdateArgs } from '../../ecs/ecs';\nimport { ActorSystem, SolidSystem } from './solidSystem';\n\nexport class MovingPlatform implements Component {\n    loopDuration: number;\n    start: Vector;\n    midpoint: Vector;\n\n    loopState: number;\n\n    constructor(loopDuration: number, start: Vector, midpoint: Vector) {\n        this.loopDuration = loopDuration;\n        this.start = start;\n        this.midpoint = midpoint;\n\n        this.loopState = 0;\n    }\n}\n\nexport class MovingPlatformSystem implements System {\n    componentSet = new Set([Solid, MovingPlatform]);\n\n    ecs!: ECS;\n\n    update(entities: Set<Entity>, { frameDuration }: UpdateArgs) {\n        const actors = this.ecs.resolveEntities(this.ecs.querySystem(ActorSystem), Actor)\n            .filter(a => !a.isNonPhysical);\n        const solids = this.ecs.resolveEntities(this.ecs.querySystem(SolidSystem), Solid);\n\n        entities.values().forEach(e => {\n            const container = this.ecs.getComponents(e);\n\n            const mover = container.get(MovingPlatform);\n            const solid = container.get(Solid);\n\n            mover.loopState += frameDuration;\n            mover.loopState %= mover.loopDuration;\n\n            const interpolationFactor = mover.loopState < mover.loopDuration / 2\n                ? mover.loopState / mover.loopDuration * 2\n                : 2 - mover.loopState / mover.loopDuration * 2;\n\n            const targetPos = {\n                x: lerp(mover.start.x, mover.midpoint.x, interpolationFactor),\n                y: lerp(mover.start.y, mover.midpoint.y, interpolationFactor),\n            };\n\n            solid.move(targetPos.x - (solid.x + solid.xRemainder), targetPos.y - (solid.y + solid.yRemainder), actors, solids);\n        });\n    }\n}\n", "import type { Rect } from '../../core/math';\nimport { isDefined } from '../../core/types';\nimport { Component, ECS, System, type Entity } from '../../ecs/ecs';\n\nexport class DrawableRect implements Component {\n    color: string | undefined;\n    rect: Rect;\n\n    constructor(rect: Rect, color?: string) {\n        this.color = color;\n        this.rect = rect;\n    }\n}\n\nexport class RectArtSystem implements System {\n    componentSet = new Set([DrawableRect]);\n\n    ecs!: ECS;\n\n    color: string;\n\n    constructor(color: string) {\n        this.color = color;\n    }\n\n    update() { }\n\n    draw(entities: Set<Entity>, ctx: CanvasRenderingContext2D) {\n        const rects = entities.values().map(e => this.ecs.getComponents(e)).filter(isDefined).map(e => e.get(DrawableRect));\n        \n        rects.forEach(({ rect, color }) => {\n            if (color) {\n                ctx.fillStyle = color;\n            } else {\n                ctx.fillStyle = this.color;\n            }\n\n            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);\n        });\n    }\n}\n", "import { DRAW_FRAME_MARKERS } from '../../constants';\nimport { Actor } from '../../core/actor';\nimport { incDecLatch, type IncDecLatch } from '../../core/latch';\nimport { approach, overlaps, type Rect, type Vector } from '../../core/math';\nimport { Sprite } from '../../core/sprite';\nimport type { Room } from '../room';\n\nimport type { EnemyInterface } from './interface';\n\nconst ENEMY_RADIUS = 24;\n\nconst X_SPEED = 300 / 1000;\nconst X_ACCEL = 1 / 1000;\nconst Y_ACCEL = 2 / 1000;\n\nconst GHOSTY_SPRITE = Sprite('./img/ghosty.png');\n\nconst ENEMY_WIDTH = 24;\nconst ENEMY_HEIGHT = 32;\nconst VISUAL_SCALE = 2;\n\nexport class Enemy implements EnemyInterface {\n    xVelocity: number;\n    yVelocity: number;\n\n    actor: Actor;\n\n    hp: number;\n    alive: boolean;\n\n    facing: 'left' | 'right';\n\n    isNonPhysical: boolean;\n\n    hurtVisualiser: IncDecLatch;\n\n    constructor(x: number, y: number) {\n        this.xVelocity = 0;\n        this.yVelocity = 0;\n\n        this.actor = new Actor(x, y, ENEMY_WIDTH * VISUAL_SCALE, ENEMY_HEIGHT * VISUAL_SCALE);\n\n        this.hp = 3;\n        this.alive = true;\n\n        this.facing = 'left';\n\n        this.isNonPhysical = true;\n\n        this.hurtVisualiser = incDecLatch(1, 250);\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        if (this.hurtVisualiser.check() > 0) {\n            ctx.filter = 'brightness(1000%) saturate(0%)';\n        }\n        ctx.drawImage(\n            GHOSTY_SPRITE,\n            this.facing === 'left' ? 0 : ENEMY_WIDTH,\n            0,\n            ENEMY_WIDTH,\n            ENEMY_HEIGHT,\n            this.actor.x,\n            this.actor.y,\n            this.actor.width,\n            this.actor.height,\n        );\n        ctx.filter = 'none';\n\n        if (DRAW_FRAME_MARKERS) {\n            ctx.strokeStyle = 'white';\n            ctx.strokeRect(this.actor.x, this.actor.y, this.actor.width, this.actor.height);\n        }\n    }\n\n    update(frameDuration: number, room: Room, playerPosition: { x: number; y: number }) {\n        this.updateVelocities(frameDuration, room, playerPosition);\n\n        if (this.isNonPhysical) {\n            this.actor.moveX(this.xVelocity * frameDuration, () => { }, []);\n            this.actor.moveY(this.yVelocity * frameDuration, () => { }, []);\n        } else {\n            this.actor.moveX(this.xVelocity * frameDuration, () => { this.xVelocity = 0 }, room.solids);\n            this.actor.moveY(this.yVelocity * frameDuration, () => { this.yVelocity = 0 }, room.solids);\n        }\n\n        this.hurtVisualiser.down(frameDuration);\n    }\n\n    updateVelocities(frameDuration: number, _room: Room, playerPosition: Vector) {\n        const myMidpoint = this.actor.getMidpoint();\n\n        if (playerPosition) {\n            if (playerPosition.x < myMidpoint.x) {\n                this.xVelocity = approach(-X_SPEED, this.xVelocity, X_ACCEL * frameDuration);\n\n                this.facing = 'left';\n            } else {\n                this.xVelocity = approach(X_SPEED, this.xVelocity, X_ACCEL * frameDuration);\n\n                this.facing = 'right';\n            }\n            if (playerPosition.y < myMidpoint.y) {\n                this.yVelocity = approach(-X_SPEED, this.yVelocity, Y_ACCEL * frameDuration);\n            } else {\n                this.yVelocity = approach(X_SPEED, this.yVelocity, Y_ACCEL * frameDuration);\n            }\n        } else {\n            this.facing = this.xVelocity < 0 ? 'left' : 'right';\n        }\n    }\n\n    applyDamage(_box: Rect, impulse: Partial<Vector>) {\n        this.hp -= 1;\n\n        this.xVelocity += impulse?.x ?? 0;\n        this.yVelocity += impulse?.y ?? 0;\n\n        if (this.hp <= 0) {\n            this.alive = false;\n        }\n\n        this.hurtVisualiser.up();\n    }\n\n    intersects(box: Rect) {\n        if (overlaps(box, this.actor)) {\n            return this.actor;\n        }\n    }\n}\n", "import { approach, overlaps, type Rect, type Vector } from '../../core/math';\nimport type { Room } from '../room';\n\nimport { Enemy } from './enemy';\n\nconst WALKING_SPEED = 180 / 1000;\nconst WALKING_ACCEL = 2 / 1000;\n\nconst GRAVITY = 2.5 / 1000;\n\nexport class Walker extends Enemy {\n    constructor(x: number, y: number) {\n        super(x, y);\n\n        this.hp = 5;\n\n        this.isNonPhysical = false;\n        this.facing = 'left';\n    }\n\n    updateVelocities(frameDuration: number, room: Room, _playerPosition: Vector) {\n        /** Do something */\n        this.yVelocity += GRAVITY * frameDuration;\n\n        const standingSolid = { x: this.actor.x, y: this.actor.y + this.actor.height, width: this.actor.width, height: 1 };\n\n        if (!room.solids.some(solid => solid.isCollidable && overlaps(solid, standingSolid))) {\n            /** Wait */\n            this.xVelocity = approach(0, this.xVelocity, WALKING_ACCEL / 2);\n        }\n\n        if (this.facing === 'left') {\n            if (this.canMoveLeft(room)) {\n                this.xVelocity = approach(-WALKING_SPEED, this.xVelocity, WALKING_ACCEL);\n            } else if (this.canMoveRight(room)) {\n                this.facing = 'right';\n                this.xVelocity = approach(0, this.xVelocity, WALKING_ACCEL);\n            }\n        } else {\n            /** Facing right case */\n            if (this.canMoveRight(room)) {\n                this.xVelocity = approach(WALKING_SPEED, this.xVelocity, WALKING_ACCEL);\n            } else if (this.canMoveLeft(room)) {\n                this.facing = 'left';\n                this.xVelocity = approach(0, this.xVelocity, WALKING_ACCEL);\n            }\n        }\n    }\n\n    canMoveLeft(room: Room) {\n        /** Currently taking for granted that we're on the ground. */\n\n        const groundSolid = { x: this.actor.x - this.actor.width / 2, y: this.actor.y + this.actor.height, width: this.actor.width / 4, height: 1 };\n        const spaceSolid = { x: this.actor.x - this.actor.width, y: this.actor.y, height: this.actor.height, width: this.actor.width };\n\n        return room.solids.some(solid => solid.isCollidable && !solid.isDroppable && overlaps(solid, groundSolid))\n            && room.solids.every(solid => !solid.isCollidable || !overlaps(solid, spaceSolid));\n    }\n\n    canMoveRight(room: Room) {\n        /** Currently taking for granted that we're on the ground. */\n\n        const groundSolid = { x: this.actor.x + this.actor.width / 4 * 5, y: this.actor.y + this.actor.height, width: this.actor.width / 4, height: 1 };\n        const spaceSolid = { x: this.actor.x + this.actor.width, y: this.actor.y, height: this.actor.height, width: this.actor.width };\n\n        return room.solids.some(solid => solid.isCollidable && !solid.isDroppable && overlaps(solid, groundSolid))\n            && room.solids.every(solid => !solid.isCollidable || solid.isDroppable || !overlaps(solid, spaceSolid));\n    }\n\n    applyDamage(box: Rect, impulse: Partial<Vector>) {\n        super.applyDamage(box, impulse);\n        this.yVelocity -= 0.3;\n    }\n}\n", "import { Solid, type SolidConfig } from '../core/solid';\n\nimport { GAP_SIZE, GAPS, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH, WALL_THICKNESS, type DoorsMap, type HorizontalDoorKey, type VerticalDoorKey } from './room';\n\ntype SolidArgs =\n    (({ x: number } | { left: number; x?: undefined }) & ({ width: number } | { right: number; width?: undefined })) &\n    (({ y: number } | { top: number; y?: undefined }) & ({ height: number } | { bottom: number; height?: undefined }));\n\nexport const createSolid = (args: SolidArgs, config?: SolidConfig) => {\n    const x = args.x ?? args.left;\n    const y = args.y ?? args.top;\n    const width = args.width ?? args.right - x;\n    const height = args.height ?? args.bottom - y;\n\n    if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height)) {\n        throw new Error('Invalid parameters to create solid!');\n    }\n\n    return new Solid(x, y, width, height, config);\n}\n\nconst getGapNames = (gapMap: Partial<Record<VerticalDoorKey | HorizontalDoorKey, boolean | undefined>> = {}) => {\n    const names = (Object.keys(gapMap) as (VerticalDoorKey | HorizontalDoorKey)[]).filter(key => gapMap[key]);\n    names.sort((a, b) => GAPS[a][0] - GAPS[b][0]);\n    return names;\n};\n\nexport const getDoorBlockingSolids = (doors: Partial<DoorsMap>) => {\n    const solids = [];\n\n    solids.push(...getGapNames(doors.left).map(name => GAPS[name]).map(([top, bottom]) =>\n        createSolid({ top, bottom, left: 0, width: WALL_THICKNESS }),\n    ));\n    solids.push(...getGapNames(doors.right).map(name => GAPS[name]).map(([top, bottom]) =>\n        createSolid({ top, bottom, left: ROOM_SCALE_WIDTH - WALL_THICKNESS, width: WALL_THICKNESS }),\n    ));\n    solids.push(...getGapNames(doors.top).map(name => GAPS[name]).map(([left, right]) =>\n        createSolid({ left, right, top: 0, height: WALL_THICKNESS }),\n    ));\n    solids.push(...getGapNames(doors.bottom).map(name => GAPS[name]).map(([left, right]) =>\n        createSolid({ left, right, top: ROOM_SCALE_HEIGHT - WALL_THICKNESS, height: WALL_THICKNESS }),\n    ));\n\n    return solids;\n};\n\nexport const generateRoomForDoors = (doors: DoorsMap) => {\n    const solids = [];\n    const blockers = [];\n\n    const gapLeft = ROOM_SCALE_WIDTH / 2 - GAP_SIZE / 2;\n    const gapRight = gapLeft + GAP_SIZE;\n\n    /** Top */\n    const topStarts = [0].concat(getGapNames(doors.top).map(name => GAPS[name][1]));\n    const topEnds = getGapNames(doors.top).map(name => GAPS[name][0]).concat(ROOM_SCALE_WIDTH);\n    solids.push(...topStarts.map((left, index) =>\n        createSolid({ left, right: topEnds[index]!, y: 0, height: WALL_THICKNESS }),\n    ));\n    blockers.push(...getGapNames(doors.top).map(name => GAPS[name]).map(([left, right]) =>\n        createSolid({ left, right, y: 0, height: WALL_THICKNESS }),\n    ));\n\n    /** Bottom */\n    const bottomStarts = [0].concat(getGapNames(doors.bottom).map(name => GAPS[name][1]));\n    const bottomEnds = getGapNames(doors.bottom).map(name => GAPS[name][0]).concat(ROOM_SCALE_WIDTH);\n    solids.push(...bottomStarts.map((left, index) =>\n        createSolid({ left, right: bottomEnds[index]!, y: ROOM_SCALE_HEIGHT - WALL_THICKNESS, height: WALL_THICKNESS }),\n    ));\n    solids.push(...getGapNames(doors.bottom).map(name =>\n        createSolid(\n            { left: GAPS[name][0], right: GAPS[name][1], top: ROOM_SCALE_HEIGHT - WALL_THICKNESS, height: WALL_THICKNESS / 4 },\n            { isDroppable: true },\n        ),\n    ));\n    blockers.push(...getGapNames(doors.bottom).map(name => GAPS[name]).map(([left, right]) =>\n        createSolid({ left, right, y: ROOM_SCALE_HEIGHT - WALL_THICKNESS, height: WALL_THICKNESS }),\n    ));\n\n    /** Left */\n    const leftStarts = [0].concat(getGapNames(doors.left).map(name => GAPS[name][1]));\n    const leftEnds = getGapNames(doors.left).map(name => GAPS[name][0]).concat(ROOM_SCALE_HEIGHT);\n    solids.push(...leftStarts.map((top, index) =>\n        createSolid({ top, bottom: leftEnds[index]!, left: 0, width: WALL_THICKNESS }),\n    ));\n    blockers.push(...getGapNames(doors.left).map(name => GAPS[name]).map(([top, bottom]) =>\n        createSolid({ top, bottom, x: 0, width: WALL_THICKNESS }),\n    ));\n\n    /** Right */\n    const rightStarts = [0].concat(getGapNames(doors.right).map(name => GAPS[name][1]));\n    const rightEnds = getGapNames(doors.right).map(name => GAPS[name][0]).concat(ROOM_SCALE_HEIGHT);\n    solids.push(...rightStarts.map((top, index) =>\n        createSolid({ top, bottom: rightEnds[index]!, left: ROOM_SCALE_WIDTH - WALL_THICKNESS, width: WALL_THICKNESS }),\n    ));\n    blockers.push(...getGapNames(doors.right).map(name => GAPS[name]).map(([top, bottom]) =>\n        createSolid({ top, bottom, x: ROOM_SCALE_WIDTH - WALL_THICKNESS, width: WALL_THICKNESS }),\n    ));\n\n    const ladders = [];\n\n    /** Add left ladder */\n    ladders.push(createSolid(\n        { left: gapLeft - GAP_SIZE, width: GAP_SIZE, top: 420, height: WALL_THICKNESS / 4 },\n        { isDroppable: true },\n    ));\n    ladders.push(createSolid(\n        { left: gapLeft - GAP_SIZE, width: GAP_SIZE, top: 570, height: WALL_THICKNESS / 4 },\n        { isDroppable: true },\n    ));\n    /** Add top platform */\n    ladders.push(createSolid(\n        { left: gapLeft, right: gapRight, top: 140, height: WALL_THICKNESS / 4 },\n        { isDroppable: true },\n    ));\n\n    return {\n        blockers: blockers.map(blocker => {\n            blocker.blocker = true;\n            blocker.color = 'brown';\n            blocker.isCollidable = false;\n            return blocker;\n        }),\n        solids,\n        ladders,\n    };\n};\n", "import { overlaps, type Vector } from '../core/math';\nimport { Solid } from '../core/solid';\nimport { ECS } from '../ecs/ecs';\nimport { createEnemy, EnemySystem } from './ecs/enemySystem';\nimport { MovingPlatform, MovingPlatformSystem } from './ecs/movingPlatformSystem';\nimport { createPlayer, PlayerComponent, PlayerSystem } from './ecs/playerSystem';\nimport { DrawableRect, RectArtSystem } from './ecs/rectArtSystem';\nimport { ActorSystem, SolidSystem } from './ecs/solidSystem';\nimport { Enemy } from './enemy/enemy';\nimport type { EnemyInterface } from './enemy/interface';\nimport { Walker } from './enemy/walker';\nimport type { Particle } from './particle';\nimport { generateRoomForDoors, getDoorBlockingSolids } from './room-utils';\n\nexport const WALL_THICKNESS = 40;\n\nexport const ROOM_SCALE_WIDTH = 1280;\nexport const ROOM_SCALE_HEIGHT = 720;\n\nexport const GAP_SIZE = WALL_THICKNESS * 6;\n\nexport const GAPS: Record<VerticalDoorKey | HorizontalDoorKey, [number, number]> = {\n    high: [120, 240],\n    medium: [ROOM_SCALE_HEIGHT / 2 - 40, ROOM_SCALE_HEIGHT / 2 + 80],\n    low: [ROOM_SCALE_HEIGHT - 160, ROOM_SCALE_HEIGHT - 40],\n\n    left: [80, 280],\n    center: [ROOM_SCALE_WIDTH / 2 - 100, ROOM_SCALE_WIDTH / 2 + 100],\n    right: [ROOM_SCALE_WIDTH - 280, ROOM_SCALE_WIDTH - 80],\n};\n\nexport type VerticalDoorKey = 'left' | 'center' | 'right';\nexport type HorizontalDoorKey = 'high' | 'medium' | 'low';\n\nconst VERTICAL_DOOR_KEYS: VerticalDoorKey[] = ['left', 'center', 'right'];\nconst HORIZONTAL_DOOR_KEYS: HorizontalDoorKey[] = ['high', 'medium', 'low'];\n\nexport type Edge = 'left' | 'right' | 'top' | 'bottom';\n\nexport type DoorsMap = {\n    left: Partial<Record<HorizontalDoorKey, boolean | undefined>>;\n    right: Partial<Record<HorizontalDoorKey, boolean | undefined>>;\n    top: Partial<Record<VerticalDoorKey, boolean | undefined>>;\n    bottom: Partial<Record<VerticalDoorKey, boolean | undefined>>;\n}\n\nexport type SemiDoorsMap = {\n    left: Partial<Record<HorizontalDoorKey, boolean | undefined>> | undefined;\n    right: Partial<Record<HorizontalDoorKey, boolean | undefined>> | undefined;\n    top: Partial<Record<VerticalDoorKey, boolean | undefined>> | undefined;\n    bottom: Partial<Record<VerticalDoorKey, boolean | undefined>> | undefined;\n};\n\nexport class Room {\n    getDoorwayChance() {\n        return 0.5;\n    }\n\n    static getDoorArrangement(): DoorsMap {\n        return {\n            top: {},\n            bottom: {},\n            left: {},\n            right: {},\n        };\n    }\n\n    static isValidAt(_x: number, _y: number) {\n        return true;\n    }\n\n    /** Default room constructor works for any door arrangement */\n    static areDoorsOk(setDoors: DoorsMap) {\n        const arr = this.getDoorArrangement();\n\n        return HORIZONTAL_DOOR_KEYS.every(key => {\n            return (arr.left[key] === undefined || setDoors.left[key] === undefined || arr.left[key] === setDoors.left[key])\n                && (arr.right[key] === undefined || setDoors.right[key] === undefined || arr.right[key] === setDoors.right[key]);\n        }) && VERTICAL_DOOR_KEYS.every(key => {\n            return (arr.top[key] === undefined || setDoors.top[key] === undefined || arr.top[key] === setDoors.top[key])\n                && (arr.bottom[key] === undefined || setDoors.bottom[key] === undefined || arr.bottom[key] === setDoors.bottom[key]);\n        });\n    }\n\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n\n    color: string;\n\n    blockersLocked: boolean;\n    allEnemiesCleared: boolean;\n\n    doors: DoorsMap;\n\n    // enemies: EnemyInterface[];\n    // solids: Solid[];\n    // particles: Particle[];\n\n    ecs: ECS;\n\n    constructor(x: number, y: number, width: number, height: number, color = 'blue', setDoors: Partial<DoorsMap> | undefined = {}) {\n        /** Room setup */\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        this.ecs = new ECS();\n\n        this.ecs.addSystem(new ActorSystem());\n        this.ecs.addSystem(new SolidSystem());\n        this.ecs.addSystem(new RectArtSystem(color));\n        this.ecs.addSystem(new PlayerSystem());\n        this.ecs.addSystem(new MovingPlatformSystem());\n        this.ecs.addSystem(new EnemySystem());\n\n        this.color = color;\n\n        this.blockersLocked = false;\n        this.allEnemiesCleared = false;\n\n        this.doors = {\n            left: setDoors.left ?? {},\n            right: setDoors.right ?? {},\n            top: setDoors.top ?? {},\n            bottom: setDoors.bottom ?? {},\n        };\n\n        // this.enemies = [];\n        // this.particles = [];\n\n        this.globalDoorwayRectification();\n        this.configureAllDoors();\n        this.configureRoomContent();\n\n        createPlayer(this.ecs, 0.5 * ROOM_SCALE_WIDTH, 0.08 * ROOM_SCALE_HEIGHT);\n    }\n\n    globalDoorwayRectification() {\n        /** Basic doorway rectification rules */\n        if (this.x === 0 && this.y === 0) {\n            this.doors = {\n                bottom: { center: true, left: false, right: false },\n                top: { center: false, left: false, right: false },\n                left: { high: false, medium: false, low: false },\n                right: { high: false, medium: false, low: false },\n            };\n        } else if (this.x === 0 && this.y === 1) {\n            this.doors.top = { center: true, left: false, right: false };\n        } else if (this.y === 1) {\n            this.doors.top = { center: false, left: false, right: false };\n        }\n    }\n\n    /** Randomise un-specified doors */\n    configureAllDoors() {\n        /** Using constructor to access the static methods of the instantiated sub-class */\n        const arr = (this.constructor as typeof Room).getDoorArrangement();\n        const odds = this.getDoorwayChance();\n\n        HORIZONTAL_DOOR_KEYS.forEach(key => {\n            if (this.doors.left[key] === undefined) {\n                this.doors.left[key] = arr.left[key] ?? Math.random() < odds;\n            }\n            if (this.doors.right[key] === undefined) {\n                this.doors.right[key] = arr.right[key] ?? Math.random() < odds;\n            }\n        });\n        VERTICAL_DOOR_KEYS.forEach(key => {\n            if (this.doors.top[key] === undefined) {\n                this.doors.top[key] = arr.top[key] ?? Math.random() < odds;\n            }\n            if (this.doors.bottom[key] === undefined) {\n                this.doors.bottom[key] = arr.bottom[key] ?? Math.random() < odds;\n            }\n        });\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { solids, blockers, ladders } = generateRoomForDoors(this.doors);\n        solids.concat(blockers).concat(ladders).forEach(solid => {\n            const e = this.ecs.addEntity();\n            this.ecs.addComponent(e, solid);\n            this.ecs.addComponent(e, new DrawableRect(solid, solid.color));\n        });\n\n        const plat = this.ecs.addEntity();\n        const platSolid = new Solid(300, 280, 200, 40)\n        this.ecs.addComponent(plat, platSolid);\n        this.ecs.addComponent(plat, new DrawableRect(platSolid, this.color));\n        this.ecs.addComponent(plat, new MovingPlatform(7000, { x: 300, y: 280 }, { x: 600, y: 280 }))\n\n        createEnemy(this.ecs, ROOM_SCALE_WIDTH, ROOM_SCALE_HEIGHT);\n        // this.enemies = [\n        //     new Walker(ROOM_SCALE_WIDTH / 4 * 3, ROOM_SCALE_HEIGHT / 2),\n        // ];\n    }\n\n    draw(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, mousePosition: Vector | undefined, interpolationFactor: number) {\n        /** Blank background */\n        ctx.fillStyle = 'black';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n        this.ecs.draw(ctx);\n    }\n\n    update(mousePosition: Vector | undefined, keyboardState: Record<string, boolean>, frameDuration: number, onRoomChange: (x: number, y: number, doors: Partial<DoorsMap>) => void) {\n        this.ecs.update({ mousePosition, keyboardState, frameDuration });\n\n        // if (!this.blockersLocked) {\n        //     if (this.solids.some(solid => solid.blocker && overlaps(this.playerState.actor, solid))) {\n        //         // Not yet\n        //     } else {\n        //         this.solids.forEach(solid => {\n        //             if (solid.blocker) {\n        //                 solid.isCollidable = true;\n        //             }\n        //         });\n        //         this.blockersLocked = true;\n        //     }\n        // }\n\n        // this.particles = this.particles.filter(particle => {\n        //     particle.update(frameDuration);\n\n        //     return particle.alive;\n        // });\n\n        // this.enemies.forEach(enemy => {\n        //     enemy.update(frameDuration, this, this.playerState.actor.getMidpoint());\n        // });\n\n        // this.enemies = this.enemies.filter(enemy => enemy.alive);\n\n        // if (!this.allEnemiesCleared && this.enemies.length === 0) {\n        //     this.onAllEnemiesCleared();\n        //     this.allEnemiesCleared = true;\n        // }\n\n        // this.validateLeavingRoom(onRoomChange);\n    }\n\n    validateLeavingRoom(onRoomChange: (x: number, y: number, doors: Partial<DoorsMap>) => void) {\n        // const playerMidpoint = this.playerState.actor.getMidpoint();\n        // if (playerMidpoint.x > ROOM_SCALE_WIDTH) {\n        //     const doors: Pick<DoorsMap, 'left'> = { left: {} };\n        //     const relevantGap = (['high', 'medium', 'low'] as const)\n        //         .find(gap => playerMidpoint.y >= GAPS[gap][0] && playerMidpoint.y < GAPS[gap][1]);\n        //     if (relevantGap) doors.left[relevantGap] = true;\n        //     onRoomChange(this.x + 1, this.y, doors);\n        // } else if (playerMidpoint.x < 0) {\n        //     const doors: Pick<DoorsMap, 'right'> = { right: {} };\n        //     const relevantGap = (['high', 'medium', 'low'] as const)\n        //         .find(gap => playerMidpoint.y >= GAPS[gap][0] && playerMidpoint.y < GAPS[gap][1]);\n        //     if (relevantGap) doors.right[relevantGap] = true;\n        //     onRoomChange(this.x - 1, this.y, doors);\n        // } else if (playerMidpoint.y > ROOM_SCALE_HEIGHT) {\n        //     const doors: Pick<DoorsMap, 'top'> = { top: {} };\n        //     const relevantGap = (['left', 'center', 'right'] as const)\n        //         .find(gap => playerMidpoint.x >= GAPS[gap][0] && playerMidpoint.x < GAPS[gap][1]);\n        //     if (relevantGap) doors.top[relevantGap] = true;\n        //     onRoomChange(this.x, this.y + 1, doors);\n        // } else if (playerMidpoint.y < 0) {\n        //     const doors: Pick<DoorsMap, 'bottom'> = { bottom: {} };\n        //     const relevantGap = (['left', 'center', 'right'] as const)\n        //         .find(gap => playerMidpoint.x >= GAPS[gap][0] && playerMidpoint.x < GAPS[gap][1]);\n        //     if (relevantGap) doors.bottom[relevantGap] = true;\n        //     onRoomChange(this.x, this.y - 1, doors);\n        // }\n    }\n\n    onAllEnemiesCleared() {\n        // this.solids = this.solids.filter(solid => !solid.blocker);\n    }\n\n    setExternalMatchingDoorways(doors: Partial<SemiDoorsMap>) {\n        const doorsToBlock: Partial<DoorsMap> = {};\n\n        for (const _face in doors) {\n            const face = _face as keyof DoorsMap;\n\n            for (const _doorway in doors[face]) {\n                const doorway = face === 'left' || face === 'right'\n                    ? _doorway as HorizontalDoorKey\n                    : _doorway as VerticalDoorKey;\n\n                if (face === 'left' || face === 'right') {\n                    const doorway = _doorway as HorizontalDoorKey;\n\n                    if (doors[face][doorway] === false && this.doors[face][doorway] === true) {\n                        doorsToBlock[face] = doorsToBlock[face] ?? {};\n                        doorsToBlock[face][doorway] = true;\n                    }\n                } else {\n                    const doorway = _doorway as VerticalDoorKey;\n\n                    if (doors[face][doorway] === false && this.doors[face][doorway] === true) {\n                        doorsToBlock[face] = doorsToBlock[face] ?? {};\n                        doorsToBlock[face][doorway] = true;\n                    }\n                }\n            }\n        }\n\n        // this.solids.push(...getDoorBlockingSolids(doorsToBlock).map(solid => {\n        //     solid.color = 'yellow';\n        //     return solid;\n        // }));\n    }\n\n    drawForMap(mapCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D) {\n        mapCtx.fillStyle = this.color;\n\n        // for (const solid of this.solids) {\n        //     if (solid.blocker) {\n        //         continue;\n        //     }\n        //     mapCtx.fillRect(solid.x, solid.y, solid.width, solid.height);\n        // }\n    }\n\n    addParticle(particle: Particle) {\n        // this.particles.push(particle);\n    }\n}\n", "import type { Rect } from '../core/math';\n\nconst GRAVITY = 2.5 / 1000;\n\nexport class Particle implements Rect {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n\n    color: string;\n    xVelocity: number;\n    yVelocity: number;\n\n    lifeLeft: number;\n    lifespan: number;\n\n    alive: boolean;\n    affectedByGravity: boolean;\n\n    constructor(x: number, y: number, width: number, height: number, color: string, vX: number, vY: number, lifespan: number, affectedByGravity = false) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.color = color;\n        this.xVelocity = vX;\n        this.yVelocity = vY;\n\n        this.lifeLeft = lifespan;\n        this.lifespan = lifespan;\n\n        this.alive = true;\n\n        this.affectedByGravity = affectedByGravity;\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        ctx.filter = `opacity(${Math.round(100 * this.lifeLeft / this.lifespan)}%)`;\n        ctx.fillStyle = this.color;\n        ctx.fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);\n        ctx.filter = 'none';\n    }\n\n    update(frameDuration: number) {\n        if (this.affectedByGravity) {\n            this.yVelocity += frameDuration * GRAVITY;\n        }\n\n        this.x += frameDuration * this.xVelocity;\n        this.y += frameDuration * this.yVelocity;\n\n        this.lifeLeft = Math.max(0, this.lifeLeft - frameDuration);\n\n        if (this.lifeLeft <= 0) {\n            this.alive = false;\n        }\n    }\n}\n", "import { DRAW_FRAME_MARKERS } from '../../../constants';\nimport { incDecLatch, type IncDecLatch } from '../../../core/latch';\nimport { distance, isPointInside, normalize, overlaps, randomPerimeterPoint, randomPointInRect, rectMidpoint, type Rect, type Vector } from '../../../core/math';\nimport { Sprite } from '../../../core/sprite';\nimport { Particle } from '../../particle';\nimport { Room, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH } from '../../room';\n\nconst GHOST_WIDTH = 200;\nconst GHOST_COLLIDER_WIDTH = 120;\n\nconst GHOST_BOSS_SPEED = 500 / 1000;\n\nconst GhostBossSprite = Sprite('./img/theghost.png');\n\nconst INSIDE_COLLIDER = {\n    x: 100,\n    y: 100,\n    width: ROOM_SCALE_WIDTH - 200,\n    height: ROOM_SCALE_HEIGHT - 200,\n};\n\nconst SCREEN_COLLIDER = {\n    x: -100,\n    y: -100,\n    width: ROOM_SCALE_WIDTH + 200,\n    height: ROOM_SCALE_HEIGHT + 200,\n};\n\nexport class GhostBoss {\n    hp: number;\n    alive: boolean;\n\n    isNonPhysical: boolean;\n    facing: 'left' | 'right';\n    x: number;\n    y: number;\n\n    xVelocity: number = 0;\n    yVelocity: number = 0;\n\n    collider: Rect;\n\n    hurtVisualiser: IncDecLatch;\n    particleCooldown: IncDecLatch;\n\n    strategy: 'initialWait' | 'flee' | 'charge';\n\n    isStrategyComplete: boolean;\n\n    distFromStart: () => number;\n    distFromTarget: () => number;\n\n    constructor(x: number, y: number) {\n        this.hp = 20;\n        this.alive = true;\n\n        this.isNonPhysical = false;\n        this.facing = 'left';\n\n        this.x = x;\n        this.y = y;\n\n        this.collider = {\n            x: this.x - GHOST_COLLIDER_WIDTH / 2,\n            y: this.y - GHOST_COLLIDER_WIDTH / 2,\n            width: GHOST_COLLIDER_WIDTH,\n            height: GHOST_COLLIDER_WIDTH,\n        };\n\n        this.hurtVisualiser = incDecLatch(1, 250);\n        this.particleCooldown = incDecLatch(1, 40);\n\n        this.strategy = 'initialWait';\n        this.isStrategyComplete = false;\n\n        this.distFromStart = () => 0;\n        this.distFromTarget = () => 0;\n    }\n\n    update(frameDuration: number, room: Room, playerPosition: Vector) {\n        this.hurtVisualiser.down(frameDuration);\n        this.particleCooldown.down(frameDuration);\n\n        switch (this.strategy) {\n            case 'initialWait':\n                if (isPointInside(INSIDE_COLLIDER, playerPosition.x, playerPosition.y)) {\n                    this.initFlee(playerPosition);\n                }\n                return;\n            case 'flee':\n                const fleeSpeedMod = 0.8 + Math.min(1.2, this.distFromStart() / 600);\n                this.collider.x += this.xVelocity * frameDuration * fleeSpeedMod;\n                this.collider.y += this.yVelocity * frameDuration * fleeSpeedMod;\n\n                if (!overlaps(SCREEN_COLLIDER, this.collider)) {\n                    this.initCharge(playerPosition);\n                }\n\n                this.addParticle(room);\n                return;\n            case 'charge':\n                const speedMod = 0.8 + Math.min(1.2, this.distFromTarget() / 600);\n                this.collider.x += this.xVelocity * frameDuration * speedMod;\n                this.collider.y += this.yVelocity * frameDuration * speedMod;\n\n                if (this.distFromTarget() <= 10) {\n                    this.initFlee(playerPosition);\n                }\n\n                this.addParticle(room);\n                return;\n        }\n    }\n\n    addParticle(room: Room) {\n        if (this.particleCooldown.check() <= 0) {\n            const pPos = randomPointInRect(this.collider);\n            const RADIUS = 4;\n            room.addParticle(new Particle(\n                pPos.x - RADIUS / 2,\n                pPos.y - RADIUS / 2,\n                4,\n                4,\n                'white',\n                this.xVelocity * 0.3,\n                this.yVelocity * 0.3,\n                360,\n                false,\n            ));\n            this.particleCooldown.up(1);\n        }\n    }\n\n    initFlee(playerPosition: Vector) {\n        this.strategy = 'flee';\n\n        const startingPoint = rectMidpoint(this.collider);\n\n        const direction = {\n            x: playerPosition.x - startingPoint.x,\n            y: playerPosition.y - startingPoint.y,\n        };\n        const speed = normalize(direction, GHOST_BOSS_SPEED);\n\n        this.xVelocity = speed.x;\n        this.yVelocity = speed.y;\n\n        this.distFromStart = () => {\n            return distance(rectMidpoint(this.collider), startingPoint);\n        }\n    }\n\n    initCharge(playerPosition: Vector) {\n        this.strategy = 'charge';\n\n        /** Choose new starting point */\n        const startingPoint = randomPerimeterPoint(SCREEN_COLLIDER);\n\n        this.collider.x = startingPoint.x - GHOST_COLLIDER_WIDTH / 2;\n        this.collider.y = startingPoint.y - GHOST_COLLIDER_WIDTH / 2;\n\n        const px = playerPosition.x;\n        const py = playerPosition.y;\n\n        const direction = {\n            x: px - startingPoint.x,\n            y: py - startingPoint.y,\n        };\n        const speed = normalize(direction, GHOST_BOSS_SPEED);\n\n        this.xVelocity = speed.x;\n        this.yVelocity = speed.y;\n\n        this.distFromTarget = () => {\n            const pos = rectMidpoint(this.collider);\n\n            return distance(pos, { x: px, y: py });\n        };\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        if (this.hurtVisualiser.check() > 0) {\n            ctx.filter = 'brightness(10000%) saturate(0%)';\n        }\n\n        const x = Math.round(this.collider.x);\n        const y = Math.round(this.collider.y);\n\n        const OFFSET = (GHOST_WIDTH - GHOST_COLLIDER_WIDTH) / 2;\n        ctx.drawImage(\n            GhostBossSprite,\n            0,\n            0,\n            GhostBossSprite.width,\n            GhostBossSprite.height,\n            x - OFFSET,\n            y - OFFSET,\n            this.collider.width + 2 * OFFSET,\n            this.collider.height + 2 * OFFSET,\n        );\n\n        ctx.filter = 'none';\n\n        if (DRAW_FRAME_MARKERS) {\n            ctx.strokeStyle = 'yellow';\n            ctx.strokeRect(x, y, this.collider.width, this.collider.height);\n        }\n    }\n\n    applyDamage(_box: Rect) {\n        this.hp -= 1;\n        this.hurtVisualiser.up(1);\n\n        if (this.hp < 0) {\n            this.alive = false;\n        }\n    }\n\n    intersects(box: Rect) {\n        if (overlaps(box, this.collider)) {\n            return this.collider;\n        }\n    }\n}\n", "import { Solid } from '../../core/solid';\nimport { GhostBoss } from '../enemy/bosses/ghost-boss';\nimport { Room, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH } from '../room';\nimport { generateRoomForDoors } from '../room-utils';\n\nexport class GhostRoom extends Room {\n    getDoorwayChance() {\n        return 0;\n    }\n\n    static getDoorArrangement() {\n        return {\n            left: {\n                high: true,\n                medium: false,\n                low: false\n            },\n            right: {\n                high: true,\n                medium: false,\n                low: false,\n            },\n            bottom: {\n                left: false,\n                center: false,\n                right: false,\n            },\n            top: {\n                left: false,\n                center: false,\n                right: false,\n            },\n        };\n    }\n\n    static isValidAt() {\n        return true;\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { solids, blockers } = generateRoomForDoors(this.doors);\n        this.solids = solids\n            .concat(blockers)\n            .concat(\n                ...[240, 390, 540].map(y =>\n                    new Solid(40, y, ROOM_SCALE_WIDTH - 80, 10, { isDroppable: true }),\n                ),\n            );\n\n        this.enemies = [\n            new GhostBoss(ROOM_SCALE_WIDTH / 2, ROOM_SCALE_HEIGHT / 2),\n        ];\n    }\n}\n", "import { Solid } from '../../core/solid';\nimport { Room, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH } from '../room';\nimport { generateRoomForDoors } from '../room-utils';\n\nexport class HRoom extends Room {\n    getDoorwayChance() {\n        return 0;\n    }\n\n    static getDoorArrangement() {\n        return {\n            left: {\n                high: false,\n                medium: false,\n                low: false\n            },\n            right: {\n                high: false,\n                medium: false,\n                low: false,\n            },\n            bottom: {\n                left: true,\n                center: false,\n                right: true,\n            },\n            top: {\n                left: true,\n                center: false,\n                right: true,\n            },\n        };\n    }\n\n    static isValidAt(_x: number, y: number) {\n        return y >= 2;\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { blockers } = generateRoomForDoors(this.doors);\n        this.solids = blockers\n            .concat(\n                new Solid(0, 0, 80, ROOM_SCALE_HEIGHT),\n                new Solid(ROOM_SCALE_WIDTH - 80, 0, 80, ROOM_SCALE_HEIGHT),\n                new Solid(280, 0, 720, 260),\n                new Solid(280, 460, 720, 260),\n                /** Lower left leg */\n                new Solid(80, ROOM_SCALE_HEIGHT - 40, 200, 10, { isDroppable: true }),\n                new Solid(120, 570, 120, 10, { isDroppable: true }),\n                new Solid(80, 460, 200, 10, { isDroppable: true }),\n                /** Upper left leg */\n                new Solid(80, 120, 200, 10, { isDroppable: true }),\n                new Solid(80, 250, 200, 10, { isDroppable: true }),\n                new Solid(80, 355, 100, 10, { isDroppable: true }),\n                /** Lower right leg */\n                new Solid(1000, ROOM_SCALE_HEIGHT - 40, 200, 10, { isDroppable: true }),\n                new Solid(1040, 570, 120, 10, { isDroppable: true }),\n                new Solid(1000, 460, 200, 10, { isDroppable: true }),\n                /** Upper right leg */\n                new Solid(1000, 120, 200, 10, { isDroppable: true }),\n                new Solid(1000, 250, 200, 10, { isDroppable: true }),\n                new Solid(1100, 355, 100, 10, { isDroppable: true }),\n            );\n    }\n}\n", "import { Solid } from '../../core/solid';\nimport { Room, ROOM_SCALE_WIDTH, type HorizontalDoorKey, type VerticalDoorKey } from '../room';\nimport { generateRoomForDoors } from '../room-utils';\n\nexport class LRoom extends Room {\n    getDoorwayChance() {\n        return 0.1;\n    }\n\n    static getDoorArrangement() {\n        return {\n            left: {},\n            right: {\n                high: false,\n                medium: false,\n                low: true,\n            },\n            bottom: {},\n            top: {\n                left: true,\n                center: false,\n                right: false,\n            },\n        };\n    }\n\n    static isValidAt(_x: number, y: number) {\n        return y >= 2;\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { solids, blockers } = generateRoomForDoors(this.doors);\n        this.solids = solids\n            .concat(blockers)\n            .concat(\n                new Solid(380, 0, ROOM_SCALE_WIDTH - 380, 450),\n                new Solid(120, 140, 120, 10, { isDroppable: true }),\n                new Solid(40, 240, 340, 10, { isDroppable: true }),\n                new Solid(this.doors?.left?.['center' as HorizontalDoorKey] ? 160 : 40, 340, this.doors.left['center' as HorizontalDoorKey] ? 220 : 340, 10, { isDroppable: true }),\n                new Solid(40, 440, 340, 10, { isDroppable: true }),\n                new Solid(40, this.doors.left['low'] ? 550 : 540, 240, 10, { isDroppable: true }),\n            );\n    }\n}\n", "import { DRAW_FRAME_MARKERS } from \"../../../constants\";\nimport { Actor } from \"../../../core/actor\";\nimport { incDecLatch, type IncDecLatch } from \"../../../core/latch\";\nimport { clampPointWithin, insetRect, overlaps, randfloat, randint, rectMidpoint, type Rect, type Vector } from \"../../../core/math\";\nimport type { Solid } from \"../../../core/solid\";\nimport { Sprite } from \"../../../core/sprite\";\nimport { Particle } from \"../../particle\";\nimport type { Room } from \"../../room\";\nimport type { EnemyInterface } from \"../interface\";\n\nconst SPITBOSS_BASE_WIDTH = 340;\nconst SPITBOSS_BASE_HEIGHT = 76;\n\nconst SPITBOSS_HEAD_WIDTH = 60;\nconst SPITBOSS_HEAD_HEIGHT = 80;\n\nconst GRAVITY = 2.5 / 1000;\n\nconst SpitBossHeadSprite = Sprite('./img/spitboss-head.png');\nconst SpitBossBaseSprite = Sprite('./img/spitboss-base.png');\nconst SpitBossSpitSprite = Sprite('./img/spitboss-spit.png');\n\nexport class SpitBoss implements EnemyInterface {\n    hp: number;\n    alive: boolean;\n\n    isNonPhysical: boolean;\n\n    x: number;\n    y: number;\n    baseBox: Rect;\n    headBox: Rect;\n\n    hurtVisualiser: IncDecLatch;\n    fireCooldown: IncDecLatch;\n\n    constructor(x: number, y: number) {\n        this.hp = 50;\n        this.alive = true;\n\n        this.isNonPhysical = false;\n\n        this.x = x;\n        this.y = y;\n\n        this.baseBox = {\n            x: this.x - SPITBOSS_BASE_WIDTH / 2,\n            y: this.y - SPITBOSS_BASE_HEIGHT,\n            width: SPITBOSS_BASE_WIDTH,\n            height: SPITBOSS_BASE_HEIGHT,\n        };\n\n        this.headBox = {\n            x: this.x - SPITBOSS_HEAD_WIDTH / 2,\n            y: Math.round(this.y - SPITBOSS_HEAD_HEIGHT - 0.75 * SPITBOSS_BASE_HEIGHT),\n            width: SPITBOSS_HEAD_WIDTH,\n            height: SPITBOSS_HEAD_HEIGHT,\n        };\n\n        this.hurtVisualiser = incDecLatch(1, 250);\n        this.fireCooldown = incDecLatch(1, 1200);\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        if (this.hurtVisualiser.check() > 0) {\n            ctx.filter = 'brightness(1000%) saturate(0%)';\n        }\n\n        const BASE_WIDTH_OFF = 8;\n        const BASE_HEIGHT_OFF = 8;\n        ctx.drawImage(\n            SpitBossBaseSprite,\n            0,\n            0,\n            SpitBossBaseSprite.width,\n            SpitBossBaseSprite.height,\n            this.baseBox.x - BASE_WIDTH_OFF,\n            this.baseBox.y - BASE_HEIGHT_OFF,\n            this.baseBox.width + 2 * BASE_WIDTH_OFF,\n            this.baseBox.height + BASE_HEIGHT_OFF,\n        );\n\n        const HEAD_OFF = 4;\n        ctx.drawImage(\n            SpitBossHeadSprite,\n            0,\n            0,\n            SpitBossHeadSprite.width,\n            SpitBossHeadSprite.height,\n            this.headBox.x - HEAD_OFF,\n            this.headBox.y - HEAD_OFF,\n            this.headBox.width + 2 * HEAD_OFF,\n            this.headBox.height + 2 * HEAD_OFF,\n        );\n\n        ctx.filter = 'none';\n\n        if (DRAW_FRAME_MARKERS) {\n            ctx.strokeStyle = 'grey';\n            ctx.strokeRect(this.baseBox.x, this.baseBox.y, this.baseBox.width, this.baseBox.height);\n\n            ctx.strokeStyle = 'yellow';\n            ctx.strokeRect(this.headBox.x, this.headBox.y, this.headBox.width, this.headBox.height);\n        }\n    }\n\n    update(frameDuration: number, room: Room, playerPosition: Vector) {\n        this.hurtVisualiser.down(frameDuration);\n\n        this.fireCooldown.down(frameDuration);\n\n        if (this.fireCooldown.check() === 0) {\n            const newProjectiles = this.createProjectile(room, playerPosition);\n\n            if (newProjectiles && newProjectiles.length > 0) {\n                this.fireCooldown.up(1);\n                room.enemies.push(...newProjectiles);\n            }\n        }\n    }\n\n    createProjectile(room: Room, playerPosition: Vector) {\n        const aboveCollider = {\n            x: this.x - 5,\n            width: 10,\n            y: 0,\n            height: this.y,\n        };\n\n        const solidsAboveMe = room.solids.filter(solid => solid.isCollidable && !solid.isDroppable && overlaps(solid, aboveCollider));\n        const maxY = solidsAboveMe.reduce((maxY, solid) => {\n            return Math.max(maxY, solid.y + solid.height);\n        }, 0);\n\n        const startingY = this.y - 100;\n\n        const acceptablePeak = startingY - maxY - SPITBALL_RADIUS;\n\n        const maxYVelocity = -Math.sqrt(2 * GRAVITY * acceptablePeak);\n\n        if (playerPosition.y <= acceptablePeak) {\n            return undefined;\n        }\n\n        const yVelocity = randfloat(0.8, 1.0) * maxYVelocity;\n\n        const determinant = yVelocity * yVelocity - 2 * GRAVITY * (startingY - playerPosition.y);\n\n        if (determinant <= 0) {\n            return undefined;\n        }\n\n        const timeToPlayerY = (-yVelocity + Math.sqrt(determinant)) / GRAVITY;\n        const xVelocity = (playerPosition.x - this.x) / timeToPlayerY;\n\n        const numToThrow = randint(1, 4);\n\n        return new Array(numToThrow).fill(0).map(() =>\n            new SpitBoss_Spit(\n                this.x,\n                startingY,\n                xVelocity + randfloat(-0.1, 0.1),\n                yVelocity + randfloat(-0.01, 0.1),\n                this,\n            ),\n        );\n    }\n\n    applyDamage(box: Rect) {\n        if (box === this.headBox) {\n            this.hp -= 3;\n            this.hurtVisualiser.up(1);\n        } else if (box === this.baseBox) {\n            this.hp -= 0.2;\n            this.hurtVisualiser.up(0.2);\n        }\n\n        if (this.hp < 0) {\n            this.alive = false;\n        }\n    }\n\n    intersects(box: Rect) {\n        if (overlaps(box, this.headBox)) {\n            return this.headBox;\n        } else if (overlaps(box, this.baseBox)) {\n            return this.baseBox;\n        }\n    }\n}\n\nconst SPITBALL_RADIUS = 14;\n\nclass SpitBoss_Spit implements EnemyInterface {\n    actor: Actor;\n    xVelocity: number;\n    yVelocity: number;\n\n    parent: SpitBoss;\n\n    alive: boolean;\n    struck: boolean;\n\n    hitVisualiser: IncDecLatch;\n\n    constructor(x: number, y: number, xVel: number, yVel: number, parent: SpitBoss) {\n        this.actor = new Actor(x - SPITBALL_RADIUS, y - SPITBALL_RADIUS, SPITBALL_RADIUS * 2, SPITBALL_RADIUS * 2);\n\n        this.xVelocity = xVel;\n        this.yVelocity = yVel;\n\n        this.parent = parent;\n\n        this.alive = true;\n\n        this.struck = false;\n\n        this.hitVisualiser = incDecLatch(1, 150);\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        const OFFSET = 2;\n        ctx.drawImage(\n            SpitBossSpitSprite,\n            0,\n            0,\n            SpitBossSpitSprite.width,\n            SpitBossSpitSprite.height,\n            this.actor.x - OFFSET,\n            this.actor.y - OFFSET,\n            this.actor.width + 2 * OFFSET,\n            this.actor.height + 2 * OFFSET,\n        );\n    }\n\n    addParticle(room: Room, origin: Vector, velocity: Vector) {\n        const PARTICLE_RADIUS = 3;\n\n        room.addParticle(new Particle(\n            origin.x - PARTICLE_RADIUS,\n            origin.y - PARTICLE_RADIUS,\n            PARTICLE_RADIUS * 2,\n            PARTICLE_RADIUS * 2,\n            Math.random() > 0.5 ? '#674cd3' : '#9e5eff',\n            velocity.x,\n            velocity.y,\n            randfloat(120, 200),\n            true,\n        ));\n    }\n\n    update(frameDuration: number, room: Room, _playerPosition: Vector) {\n        this.hitVisualiser.down(frameDuration);\n\n        const wallHit = (drn: 'x' | 'y') => (solid: Solid) => {\n            this.alive = false;\n\n            const origin = drn === 'x'\n                ? {\n                    x: this.xVelocity > 0 ? solid.x : solid.x + solid.width,\n                    y: this.actor.y + this.actor.height / 2,\n                }\n                : {\n                    x: this.actor.x + this.actor.width / 2,\n                    y: this.yVelocity > 0 ? solid.y : solid.y + solid.height,\n                };\n\n            for (let i = 0; i < 12; i++) {\n                const vel = drn === 'x'\n                    ? {\n                        x: -this.xVelocity * randfloat(0.4, 0.6),\n                        y: randfloat(-0.2, 0.2),\n                    }\n                    : {\n                        x: randfloat(-0.2, 0.2),\n                        y: -this.yVelocity * randfloat(0.2, 0.3),\n                    };\n\n                this.addParticle(room, origin, vel);\n            }\n        };\n\n        this.yVelocity += GRAVITY * frameDuration;\n        this.actor.moveX(this.xVelocity * frameDuration, wallHit('x'), room.solids);\n        this.actor.moveY(this.yVelocity * frameDuration, wallHit('y'), room.solids);\n\n        /** See if we apply damage to parent */\n        if (this.struck && this.parent.alive) {\n            const hitBox = this.parent.intersects(this.actor);\n\n            if (hitBox) {\n                this.parent.applyDamage(hitBox);\n\n                const origin = clampPointWithin(rectMidpoint(this.actor), insetRect(hitBox, 16));\n\n                for (let i = 0; i < 12; i++) {\n                    const vel = {\n                        x: -this.xVelocity * randfloat(0.4, 0.6) + randfloat(-0.2, 0.2),\n                        y: -this.yVelocity * randfloat(0.2, 0.3) + randfloat(-0.2, 0.2),\n                    };\n\n                    this.addParticle(room, origin, vel);\n                }\n\n                this.alive = false;\n            }\n        }\n    }\n\n    applyDamage(_box: Rect, impulse: Partial<Vector>) {\n        this.hitVisualiser.up(1);\n\n        this.xVelocity = impulse?.x ?? 0;\n        this.yVelocity = impulse?.y ?? 0;\n        this.struck = true;\n    }\n\n    intersects(box: Rect) {\n        if (overlaps(box, this.actor)) {\n            return this.actor;\n        }\n    }\n}\n", "import { Solid } from '../../core/solid';\nimport { SpitBoss } from '../enemy/bosses/spit-boss';\nimport { Room, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH, type DoorsMap } from '../room';\nimport { generateRoomForDoors } from '../room-utils';\n\nexport class PitRoom extends Room {\n    getDoorwayChance() {\n        return 0.1;\n    }\n\n    static getDoorArrangement(): DoorsMap {\n        return {\n            left: {\n                high: false,\n                medium: false,\n                low: false,\n            },\n            right: {\n                high: false,\n                medium: false,\n                low: false,\n            },\n            bottom: {\n                left: false,\n                center: false,\n                right: false,\n            },\n            top: {\n                left: false,\n                center: true,\n                right: false,\n            },\n        };\n    }\n\n    static isValidAt(_x: number, _y: number) {\n        return true;\n        // return y >= 3 && x !== 0;\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { solids, blockers } = generateRoomForDoors(this.doors);\n        this.solids = solids\n            .concat(blockers)\n            .concat(\n                new Solid(320, 160, 920, 40),\n                new Solid(840, 0, 440, 200),\n                new Solid(0, 0, 80, ROOM_SCALE_HEIGHT),\n                new Solid(ROOM_SCALE_WIDTH - 80, 0, 80, ROOM_SCALE_HEIGHT),\n                new Solid(0, ROOM_SCALE_HEIGHT - 80, ROOM_SCALE_WIDTH, 80),\n                new Solid(80, 160, 240, 10, { isDroppable: true }),\n            );\n\n        this.enemies = [\n            new SpitBoss(780, ROOM_SCALE_HEIGHT - 80),\n        ];\n    }\n\n    onAllEnemiesCleared() {\n        super.onAllEnemiesCleared();\n\n        this.solids = this.solids.concat(\n            ...[320, 480].map(y =>\n                new Solid(80, y, 240, 10, { isDroppable: true }),\n            ),\n        );\n    }\n}\n", "import { Solid } from '../../core/solid';\nimport { isDefined } from '../../core/types';\nimport { Walker } from '../enemy/walker';\nimport { Room, ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH } from '../room';\nimport { generateRoomForDoors } from '../room-utils';\n\nexport class TRoom extends Room {\n    getDoorwayChance() {\n        return 0;\n    }\n\n    static getDoorArrangement() {\n        return {\n            left: {\n                high: true,\n                medium: false,\n                low: false,\n            },\n            right: {\n                high: true,\n                medium: false,\n                low: false,\n            },\n            bottom: {\n                left: false,\n                center: true,\n                right: false,\n            },\n            top: {},\n        };\n    }\n\n    /** Create room with outer boundary, a few ladders, enemies, and a moving platform */\n    configureRoomContent() {\n        /** Inner room setup */\n        const { solids, blockers } = generateRoomForDoors(this.doors);\n        this.solids = solids\n            .concat(blockers)\n            .concat(\n                new Solid(0, 240, 440, ROOM_SCALE_HEIGHT - 240),\n                new Solid(840, 240, ROOM_SCALE_WIDTH - 840, ROOM_SCALE_HEIGHT - 240),\n                new Solid(440, 240, 400, 10, { isDroppable: true }),\n                new Solid(440, 380, 400, 10, { isDroppable: true }),\n                new Solid(440, 520, 400, 10, { isDroppable: true }),\n            )\n            .concat(\n                ...[\n                    this.doors.top['left'] ? new Solid(120, 120, 120, 10, { isDroppable: true }) : undefined,\n                    this.doors.top['center'] ? new Solid(580, 120, 120, 10, { isDroppable: true }) : undefined,\n                    this.doors.top['right'] ? new Solid(1040, 120, 120, 10, { isDroppable: true }) : undefined,\n                ].filter(isDefined),\n            );\n\n        this.enemies = [\n            new Walker(ROOM_SCALE_WIDTH / 4, 176),\n            new Walker(ROOM_SCALE_WIDTH * 3 / 4, 176),\n        ];\n    }\n}\n", "import { randint } from './core/math';\nimport { GhostRoom } from './room/layouts/ghost_room';\nimport { HRoom } from './room/layouts/h_room';\nimport { LRoom } from './room/layouts/l_room';\nimport { PitRoom } from './room/layouts/pit_room';\nimport { TRoom } from './room/layouts/t_room';\nimport { Room, type DoorsMap } from './room/room';\n\nconst MAP_ROOM_WIDTH = 128;\nconst MAP_ROOM_HEIGHT = 72;\nconst DEFAULT_MAP_WIDTH = 9;\nconst DEFAULT_MAP_HEIGHT = 6;\n\nconst MAP_ROOM_SCALE = 1 / 10;\n\nconst CURRENT_ROOM_BORDER = 2;\n\n/** Amount to jump canvas size up by when re-drawing. */\nconst INCREMENT_BY = 4;\n\nexport class WorldMap {\n    lastRoomIndex: { x: number; y: number };\n    map: Record<string, Room>;\n\n    x: number;\n    y: number;\n    currentIndex: string;\n\n    minX: number;\n    minY: number;\n\n    canvas: OffscreenCanvas;\n    ctx: OffscreenCanvasRenderingContext2D;\n\n    constructor() {\n        this.lastRoomIndex = { x: 0, y: 0 };\n\n        this.map = {};\n        this.x = 0;\n        this.y = 0;\n        this.currentIndex = this.index(0, 0);\n\n        this.minX = 0;\n        this.minY = 0;\n\n        const room = new Room(0, 0, 1, 1);\n\n        this.map[this.index(0, 0)] = room;\n\n        const cols = Math.max(DEFAULT_MAP_WIDTH);\n        const rows = Math.max(DEFAULT_MAP_HEIGHT);\n\n        this.canvas = new OffscreenCanvas(cols * MAP_ROOM_WIDTH, rows * MAP_ROOM_HEIGHT);\n        const ctx = this.canvas.getContext('2d');\n\n        if (!ctx) {\n            throw Error('Could not construct canvas');\n        }\n\n        this.ctx = ctx;\n\n        this.redrawWorldMap();\n    }\n\n    createNewCanvas(minX: number, maxX: number, minY: number, maxY: number) {\n        const cols = Math.max(DEFAULT_MAP_WIDTH, maxX - minX + 1 + INCREMENT_BY);\n        const rows = Math.max(DEFAULT_MAP_HEIGHT, maxY - minY + 1 + INCREMENT_BY);\n\n        this.canvas = new OffscreenCanvas(cols * MAP_ROOM_WIDTH, rows * MAP_ROOM_HEIGHT);\n\n        const ctx = this.canvas.getContext('2d');\n\n        if (!ctx) {\n            throw Error('Could not construct canvas');\n        }\n\n        this.ctx = ctx;\n    }\n\n    getNeighboringDoors(x: number, y: number) {\n        return {\n            right: { ...this.map[this.index(x + 1, y)]?.doors?.left },\n            left: { ...this.map[this.index(x - 1, y)]?.doors?.right },\n            top: { ...this.map[this.index(x, y - 1)]?.doors?.bottom },\n            bottom: { ...this.map[this.index(x, y + 1)]?.doors?.top },\n        };\n    }\n\n    generateRoomChoices(x: number, y: number, suggestedDoors: Partial<DoorsMap> = {}) {\n        const makeColor = () => `hsl(${randint(0, 360)}, 60%, 60%)`;\n\n        const cloneDoors = () => ({\n            left: { ...(suggestedDoors.left ?? {}) },\n            right: { ...(suggestedDoors.right ?? {}) },\n            top: { ...(suggestedDoors.top ?? {}) },\n            bottom: { ...(suggestedDoors.bottom ?? {}) },\n        });\n\n        const CONSTRUCTORS = [GhostRoom, HRoom, LRoom, TRoom, PitRoom];\n\n        const checkDoors = cloneDoors();\n\n        const acceptableConstructors = CONSTRUCTORS.filter(Class =>\n            Class.isValidAt(x, y) && Class.areDoorsOk(checkDoors),\n        );\n\n        /** TODO: Shuffle constructors */\n\n        /** Pad with auto-generators */\n        acceptableConstructors.push(Room, Room, Room);\n\n        const choices = [];\n\n        for (let i = 0; i < 3; i++) {\n            const RoomType = acceptableConstructors.shift();\n\n            if (!RoomType) {\n                throw new Error('Could not find enough rooms');\n            }\n\n            /** Must re-compute neighboring doors for each as otherwise each instance will be shared. */\n            choices.push(new RoomType(x, y, 1, 1, makeColor(), cloneDoors()));\n        }\n\n        return choices;\n    }\n\n    redrawWorldMap() {\n        let maxX = 0, maxY = 0;\n\n        for (const room of Object.values(this.map)) {\n            this.minX = Math.min(this.minX, room.x);\n            maxX = Math.max(maxX, room.x);\n            this.minY = Math.min(this.minY, room.y);\n            maxY = Math.max(maxY, room.y);\n        }\n\n        if (maxX - this.minX + 1 > this.canvas.width / MAP_ROOM_WIDTH || maxY - this.minY + 1 > this.canvas.height / MAP_ROOM_HEIGHT) {\n            this.createNewCanvas(this.minX, maxX, this.minY, maxY);\n        }\n\n        this.ctx.fillStyle = 'black';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        for (const room of Object.values(this.map)) {\n            this.ctx.save();\n            this.ctx.translate((room.x - this.minX) * MAP_ROOM_WIDTH, (room.y - this.minY) * MAP_ROOM_HEIGHT);\n            this.ctx.scale(MAP_ROOM_SCALE, MAP_ROOM_SCALE);\n\n            room.drawForMap(this.ctx);\n\n            this.ctx.restore();\n        }\n    }\n\n    drawMapToScreen(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number) {\n        const drawWidth = Math.min(width, this.canvas.width);\n        const drawHeight = Math.min(height, this.canvas.height);\n\n        const xOffset = (-this.minX + this.x + 1 / 2) * MAP_ROOM_WIDTH - width / 2;\n\n        ctx.drawImage(this.canvas, xOffset, 0, drawWidth, drawHeight, x, y, drawWidth, drawHeight);\n\n        ctx.strokeStyle = 'white';\n        ctx.lineWidth = CURRENT_ROOM_BORDER;\n        ctx.strokeRect(\n            -xOffset + (this.x - this.minX + 1 / 2) * MAP_ROOM_WIDTH - CURRENT_ROOM_BORDER,\n            y + this.y * MAP_ROOM_HEIGHT - CURRENT_ROOM_BORDER,\n            MAP_ROOM_WIDTH + CURRENT_ROOM_BORDER * 2,\n            MAP_ROOM_HEIGHT + CURRENT_ROOM_BORDER * 2,\n        );\n    }\n\n    index(x: number, y: number) {\n        return `${x},${y}`;\n    }\n\n    getCurrentRoom(): Room {\n        return this.map[this.currentIndex]!;\n    }\n\n    getPreviousRoom(): Room {\n        return this.map[this.index(this.lastRoomIndex.x, this.lastRoomIndex.y)]!;\n    }\n\n    hasRoom(x: number, y: number) {\n        const index = this.index(x, y);\n\n        return index in this.map;\n    }\n\n    enterRoom(x: number, y: number) {\n        this.lastRoomIndex = { x: this.x, y: this.y };\n\n        this.x = x;\n        this.y = y;\n        this.currentIndex = this.index(x, y);\n\n        this.redrawWorldMap();\n    }\n\n    addRoom(room: Room) {\n        if (this.map[this.currentIndex]) {\n            throw new Error('Adding room where we already have one!');\n        }\n\n        this.map[this.currentIndex] = room;\n\n        /** Left room */\n        this.map[this.index(this.x - 1, this.y)]?.setExternalMatchingDoorways?.({\n            right: room.doors.left,\n        });\n        /** Right room */\n        this.map[this.index(this.x + 1, this.y)]?.setExternalMatchingDoorways?.({\n            left: room.doors.right,\n        });\n        /** Top room */\n        this.map[this.index(this.x, this.y - 1)]?.setExternalMatchingDoorways?.({\n            bottom: room.doors.top,\n        });\n        /** Bottom room */\n        this.map[this.index(this.x, this.y + 1)]?.setExternalMatchingDoorways?.({\n            top: room.doors.bottom,\n        });\n\n        room.setExternalMatchingDoorways({\n            left: this.map[this.index(this.x - 1, this.y)]?.doors?.right,\n            right: this.map[this.index(this.x + 1, this.y)]?.doors?.left,\n            top: this.map[this.index(this.x, this.y - 1)]?.doors?.bottom,\n            bottom: this.map[this.index(this.x, this.y + 1)]?.doors?.top,\n        });\n\n        this.redrawWorldMap();\n    }\n}\n", "import { latch, type BooleanLatch } from './core/latch';\nimport { isPointInside, type Vector } from './core/math';\nimport { PlayerComponent, PlayerSystem } from './room/ecs/playerSystem';\nimport { ROOM_SCALE_HEIGHT, ROOM_SCALE_WIDTH, type DoorsMap, type Room } from './room/room';\nimport { WorldMap } from './worldMap';\n\nconst FRAME_DURATION = 10;\n\nconst MAP_KEY = 'Tab';\n\nconst MAP_INSET = 64;\nconst MAP_BORDER = 4;\n\nexport class CaveWorld {\n    worldMap: WorldMap;\n\n    lastFrameTime: number;\n    unprocessedTime: number;\n\n    pausedFor: 'Tab' | 'choices' | undefined;\n    choosing: boolean;\n    choices: Room[];\n\n    tabLatch: BooleanLatch;\n    mouseOverChoiceIndex: number;\n    firstTickInNewRoom: boolean;\n\n    constructor() {\n        this.worldMap = new WorldMap();\n\n        this.lastFrameTime = performance.now();\n        this.unprocessedTime = 0;\n\n        this.pausedFor = undefined;\n        this.choosing = true;\n        this.choices = [];\n\n        this.tabLatch = latch(false);\n\n        this.mouseOverChoiceIndex = -1;\n\n        this.firstTickInNewRoom = false;\n    }\n\n    /** Update loop */\n    update(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, mousePosition: Vector | undefined, keyboardState: Record<string, boolean>) {\n        this.tabLatch(\n            !!keyboardState[MAP_KEY],\n            {\n                onLock: () => {\n                    if (this.pausedFor === 'Tab') {\n                        this.lastFrameTime = performance.now();\n                        this.pausedFor = undefined;\n                    } else {\n                        if (!this.pausedFor) {\n                            this.pausedFor = 'Tab';\n                        }\n                    }\n                },\n            },\n        );\n\n        /** Choices setup */\n        if (this.pausedFor === 'choices') {\n            if (this.choices.length === 0) {\n                this.choices = this.worldMap.generateRoomChoices(this.worldMap.x, this.worldMap.y);\n            }\n\n            this.draw(ctx, canvas, mousePosition, 0);\n            this.drawMap(ctx, canvas);\n            this.drawOptions(ctx, canvas, mousePosition);\n            return;\n        } else if (this.pausedFor === 'Tab') {\n            this.draw(ctx, canvas, mousePosition, 0);\n\n            this.drawMap(ctx, canvas);\n            return;\n        }\n\n        /** Time computation */\n        const currentTime = performance.now();\n        const elapsedTime = this.firstTickInNewRoom ? 0 : Math.min(currentTime - this.lastFrameTime, 250);\n        this.lastFrameTime = currentTime;\n\n        this.firstTickInNewRoom = false;\n\n        this.unprocessedTime += elapsedTime;\n\n        while (this.unprocessedTime >= FRAME_DURATION && !this.pausedFor) {\n            this.simulateFrame(mousePosition, keyboardState);\n\n            this.unprocessedTime -= FRAME_DURATION;\n        }\n\n        if (this.pausedFor) {\n            this.unprocessedTime = 0;\n        }\n\n        const interpolationFactor = this.unprocessedTime / FRAME_DURATION;\n\n        this.draw(ctx, canvas, mousePosition, interpolationFactor);\n    }\n\n    drawMap(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) {\n        ctx.fillStyle = '#00000099';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n        ctx.fillStyle = 'white';\n        ctx.fillRect(MAP_INSET - MAP_BORDER, MAP_INSET - MAP_BORDER, canvas.height - (MAP_INSET - MAP_BORDER) * 2, canvas.height - (MAP_INSET - MAP_BORDER) * 2);\n\n        ctx.fillStyle = 'black';\n        ctx.fillRect(MAP_INSET, MAP_INSET, canvas.height - MAP_INSET * 2, canvas.height - MAP_INSET * 2);\n\n        this.worldMap.drawMapToScreen(ctx, MAP_INSET, MAP_INSET, canvas.height - MAP_INSET * 2, canvas.height - MAP_INSET * 2);\n    }\n\n    click(_canvas: HTMLCanvasElement, _mousePosition: Vector) {\n        const choosing = this.pausedFor === 'choices' && this.choices.length > 0;\n        const mousingOverValidOption = this.mouseOverChoiceIndex >= 0 && this.mouseOverChoiceIndex < this.choices.length;\n\n        if (choosing && mousingOverValidOption) {\n            const newRoom = this.choices[this.mouseOverChoiceIndex]!;\n            this.worldMap.addRoom(newRoom);\n\n            const lastRoom = this.worldMap.getPreviousRoom();\n            this.transferPlayerPosition(lastRoom, newRoom);\n\n            this.unprocessedTime = 0;\n            this.firstTickInNewRoom = true;\n\n            this.pausedFor = undefined;\n            this.choices = [];\n        }\n    }\n\n    transferPlayerPosition(lastRoom: Room, newRoom: Room) {\n        const oldPlayerEntities = lastRoom.ecs.querySystem(PlayerSystem);\n        const newPlayerEntities = newRoom.ecs.querySystem(PlayerSystem);\n\n        if (oldPlayerEntities?.size !== 1 || newPlayerEntities?.size !== 1) {\n            return;\n        }\n\n        const oldPlayer = lastRoom.ecs.getComponents(Array.from(oldPlayerEntities.values())[0]!);\n        const newPlayer = newRoom.ecs.getComponents(Array.from(newPlayerEntities.values())[0]!);\n\n        if (!oldPlayer || !newPlayer) {\n            return;\n        }\n\n        const oldComp = oldPlayer.get(PlayerComponent);\n        const newComp = newPlayer.get(PlayerComponent);\n        // newComp.playerState.xVelocity = oldComp.playerState.xVelocity;\n        // /** Cap player y velocity when falling room to room */\n        // newComp.playerState.yVelocity = Math.min(oldComp.playerState.yVelocity, 0.1);\n\n        // const worldX = oldComp.playerState.actor.x + lastRoom.x * ROOM_SCALE_WIDTH;\n        // const worldY = oldComp.playerState.actor.y + lastRoom.y * ROOM_SCALE_HEIGHT;\n\n        // newComp.playerState.actor.x = worldX - newRoom.x * ROOM_SCALE_WIDTH;\n        // newComp.playerState.actor.y = worldY - newRoom.y * ROOM_SCALE_HEIGHT;\n\n        // /** If falling room to room cap their new y to 1px down */\n        // if (newRoom.y >= lastRoom.y + lastRoom.height) {\n        //     newComp.playerState.actor.y = Math.min(newComp.playerState.actor.y, 1);\n        // } else if (newRoom.y + newRoom.height <= lastRoom.y) {\n        //     newComp.playerState.yVelocity = Math.min(-1.1, newComp.playerState.yVelocity);\n        // }\n\n        // newComp.playerState.facing = oldComp.playerState.facing;\n    }\n\n    simulateFrame(mousePosition: Vector | undefined, keyboardState: Record<string, boolean>) {\n        const room = this.worldMap.getCurrentRoom();\n        room.update(mousePosition, keyboardState, FRAME_DURATION, this.onRoomChange.bind(this));\n    }\n\n    onRoomChange(x: number, y: number, doors: Partial<DoorsMap>) {\n        if (this.worldMap.hasRoom(x, y)) {\n            this.worldMap.enterRoom(x, y);\n\n            this.transferPlayerPosition(this.worldMap.getPreviousRoom(), this.worldMap.getCurrentRoom());\n        } else {\n            this.pausedFor = 'choices';\n            this.worldMap.enterRoom(x, y);\n            this.choices = this.worldMap.generateRoomChoices(this.worldMap.x, this.worldMap.y, doors);\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, mousePosition: Vector | undefined, interpolationFactor: number) {\n        const room = this.worldMap.getCurrentRoom();\n\n        if (room) {\n            room.draw(ctx, canvas, mousePosition, interpolationFactor);\n        }\n    }\n\n    drawOptions(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, mousePosition: Vector | undefined) {\n        this.mouseOverChoiceIndex = -1;\n\n        for (let i = 0; i < this.choices.length; i++) {\n            const roomChoice = this.choices[i]!;\n\n            const left = canvas.height;\n            const right = canvas.width;\n            const middle = (left + right) / 2;\n            const height = canvas.height / this.choices.length;\n            const top = height * i;\n            const bottom = top + height;\n\n            ctx.save();\n            ctx.translate(middle, (top + bottom) / 2);\n\n            const mouseInside = mousePosition && isPointInside({\n                x: left,\n                y: top,\n                width: right - left,\n                height,\n            }, mousePosition.x, mousePosition.y);\n\n            const scaleFactor = (right - left) / ROOM_SCALE_WIDTH * 0.5;\n\n            ctx.scale(scaleFactor, scaleFactor);\n\n            if (mouseInside) {\n                this.mouseOverChoiceIndex = i;\n                ctx.scale(1.1, 1.1);\n            }\n\n            ctx.translate(-ROOM_SCALE_WIDTH / 2, -ROOM_SCALE_HEIGHT / 2);\n\n            roomChoice.drawForMap(ctx);\n\n            ctx.restore();\n        }\n    }\n}\n", "import { CaveWorld } from \"./caveWorld\";\nimport type { Vector } from \"./core/math\";\n\nfunction main() {\n    /** Page setup */\n    const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n\n    if (!canvas) {\n        console.error('Could not find canvas');\n        return;\n    }\n\n    const ctx = canvas.getContext('2d')!;\n\n    if (!ctx) {\n        throw Error('Could not set up canvas rendering context');\n    }\n\n    ctx.imageSmoothingEnabled = false;\n\n    /** Game init */\n    const caves = new CaveWorld();\n\n    /** Mouse-related event listeners */\n    let mousePosition: Vector | undefined;\n    canvas.addEventListener('mousemove', e => {\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n\n        mousePosition = { x, y };\n    });\n\n    canvas.addEventListener('mouseleave', () => {\n        mousePosition = undefined;\n    });\n\n    canvas.addEventListener('click', e => {\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n\n        mousePosition = { x, y };\n\n        caves.click(canvas, mousePosition);\n    });\n\n    /** Keyboard event listeners */\n    let keyboardState: Record<string, boolean> = {};\n    window.addEventListener('keydown', e => {\n        keyboardState[e.key] = true;\n        if (e.key === 'Tab' || e.key === ' ') {\n            e.preventDefault();\n        }\n    });\n\n    window.addEventListener('keyup', e => {\n        delete keyboardState[e.key];\n    });\n\n    window.addEventListener('blur', () => {\n        keyboardState = {};\n    });\n\n    /** Game loop */\n    function loop() {\n        caves.update(ctx, canvas, mousePosition, keyboardState);\n\n        requestAnimationFrame(loop);\n    }\n\n    loop();\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    main();\n});\n"],
  "mappings": "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",
  "names": ["latch", "initialState", "state", "newState", "onLock", "onRelease", "incDecLatch", "stepsUp", "stepsDown", "by", "lerp", "a", "b", "t", "randint", "lo", "hi", "randfloat", "overlaps", "isPointInside", "rect", "x", "y", "square", "approach", "target", "current", "step", "clamp", "clampPointWithin", "vector", "insetRect", "insetBy", "rectMidpoint", "normalize", "radius", "magnitude", "distance", "p1", "p2", "randomPerimeterPoint", "halfPerimeter", "pos", "randomPointInRect", "Solid", "x", "y", "width", "height", "config", "actors", "solids", "moveX", "moveY", "riding", "actor", "overlaps", "a", "Actor", "x", "y", "width", "height", "isDropping", "solid", "overlaps", "amount", "onCollide", "solids", "move", "sign", "collidingSolid", "droppingThroughSolids", "groundingCollider", "groundingSolid", "Sprite", "src", "sprite", "isDefined", "item", "JumpController", "keyboardState", "frameDuration", "yVelocity", "isJumping", "nowGrounded", "nowJumping", "ComponentContainer", "component", "componentClass", "ECS", "entity", "container", "system", "systemClass", "entities", "e", "c", "args", "ctx", "systemSet", "componentContainer", "Velocity", "vel", "SolidSystem", "Solid", "entities", "players", "PlayerSystem", "Actor", "blockers", "solid", "blocker", "player", "overlaps", "ActorSystem", "frameDuration", "actorEntities", "a", "solids", "actorEntity", "actor", "colliders", "v", "LEFT_KEY", "DOWN_KEY", "RIGHT_KEY", "SPRITE_WIDTH", "SPRITE_HEIGHT", "PLAYER_WIDTH", "PLAYER_HEIGHT", "SPEED", "PLAYER_X_ACCEL", "JUMP_MAGNITUDE", "PLAYER_SPRITE", "Sprite", "getImageCoordinates", "attacking", "facing", "hasShield", "x", "y", "PlayerComponent", "JumpController", "PlayerSystem", "Actor", "Velocity", "entities", "frameDuration", "keyboardState", "e", "isDefined", "actor", "velocity", "playerComponent", "xInput", "RIGHT_KEY", "LEFT_KEY", "approach", "yAcceleration", "isJumping", "DOWN_KEY", "ctx", "isAttacking", "sx", "sy", "createPlayer", "ecs", "player", "X_SPEED", "X_ACCEL", "Y_ACCEL", "GHOSTY_SPRITE", "Sprite", "SPRITE_WIDTH", "SPRITE_HEIGHT", "ENEMY_WIDTH", "ENEMY_HEIGHT", "EnemyComponent", "incDecLatch", "EnemySystem", "Actor", "Velocity", "entities", "frameDuration", "players", "PlayerSystem", "p", "rectMidpoint", "e", "enemy", "enemyC", "myMid", "v", "target", "point", "bestDist", "thisDist", "distance", "approach", "ctx", "actor", "createEnemy", "ecs", "x", "y", "MovingPlatform", "loopDuration", "start", "midpoint", "MovingPlatformSystem", "Solid", "entities", "frameDuration", "actors", "ActorSystem", "Actor", "a", "solids", "SolidSystem", "e", "container", "mover", "solid", "interpolationFactor", "targetPos", "lerp", "DrawableRect", "rect", "color", "RectArtSystem", "entities", "ctx", "e", "isDefined", "X_SPEED", "X_ACCEL", "Y_ACCEL", "GHOSTY_SPRITE", "Sprite", "ENEMY_WIDTH", "ENEMY_HEIGHT", "VISUAL_SCALE", "Enemy", "x", "y", "Actor", "incDecLatch", "ctx", "frameDuration", "room", "playerPosition", "_room", "myMidpoint", "approach", "_box", "impulse", "box", "overlaps", "WALKING_SPEED", "WALKING_ACCEL", "GRAVITY", "Walker", "Enemy", "x", "y", "frameDuration", "room", "_playerPosition", "standingSolid", "solid", "overlaps", "approach", "groundSolid", "spaceSolid", "box", "impulse", "createSolid", "args", "config", "x", "y", "width", "height", "Solid", "getGapNames", "gapMap", "names", "key", "a", "b", "GAPS", "generateRoomForDoors", "doors", "solids", "blockers", "gapLeft", "ROOM_SCALE_WIDTH", "GAP_SIZE", "gapRight", "topStarts", "getGapNames", "name", "GAPS", "topEnds", "left", "index", "createSolid", "WALL_THICKNESS", "right", "bottomStarts", "bottomEnds", "ROOM_SCALE_HEIGHT", "leftStarts", "leftEnds", "top", "bottom", "rightStarts", "rightEnds", "ladders", "blocker", "WALL_THICKNESS", "ROOM_SCALE_WIDTH", "ROOM_SCALE_HEIGHT", "GAP_SIZE", "GAPS", "VERTICAL_DOOR_KEYS", "HORIZONTAL_DOOR_KEYS", "Room", "_x", "_y", "setDoors", "arr", "key", "x", "y", "width", "height", "color", "ECS", "ActorSystem", "SolidSystem", "RectArtSystem", "PlayerSystem", "MovingPlatformSystem", "EnemySystem", "createPlayer", "odds", "solids", "blockers", "ladders", "generateRoomForDoors", "solid", "e", "DrawableRect", "plat", "platSolid", "Solid", "MovingPlatform", "createEnemy", "ctx", "canvas", "mousePosition", "interpolationFactor", "keyboardState", "frameDuration", "onRoomChange", "doors", "doorsToBlock", "_face", "face", "_doorway", "doorway", "mapCtx", "particle", "Particle", "x", "y", "width", "height", "color", "vX", "vY", "lifespan", "affectedByGravity", "ctx", "frameDuration", "GHOST_WIDTH", "GHOST_COLLIDER_WIDTH", "GHOST_BOSS_SPEED", "GhostBossSprite", "Sprite", "INSIDE_COLLIDER", "ROOM_SCALE_WIDTH", "ROOM_SCALE_HEIGHT", "SCREEN_COLLIDER", "GhostBoss", "x", "y", "incDecLatch", "frameDuration", "room", "playerPosition", "isPointInside", "fleeSpeedMod", "overlaps", "speedMod", "pPos", "randomPointInRect", "RADIUS", "Particle", "startingPoint", "rectMidpoint", "direction", "speed", "normalize", "distance", "randomPerimeterPoint", "px", "py", "pos", "ctx", "OFFSET", "_box", "box", "GhostRoom", "Room", "solids", "blockers", "generateRoomForDoors", "y", "Solid", "ROOM_SCALE_WIDTH", "GhostBoss", "ROOM_SCALE_HEIGHT", "HRoom", "Room", "_x", "y", "blockers", "generateRoomForDoors", "Solid", "ROOM_SCALE_HEIGHT", "ROOM_SCALE_WIDTH", "LRoom", "Room", "_x", "y", "solids", "blockers", "generateRoomForDoors", "Solid", "ROOM_SCALE_WIDTH", "SPITBOSS_BASE_WIDTH", "SPITBOSS_BASE_HEIGHT", "SPITBOSS_HEAD_WIDTH", "SPITBOSS_HEAD_HEIGHT", "GRAVITY", "SpitBossHeadSprite", "Sprite", "SpitBossBaseSprite", "SpitBossSpitSprite", "SpitBoss", "x", "y", "incDecLatch", "ctx", "BASE_WIDTH_OFF", "BASE_HEIGHT_OFF", "HEAD_OFF", "frameDuration", "room", "playerPosition", "newProjectiles", "aboveCollider", "maxY", "solid", "overlaps", "startingY", "acceptablePeak", "SPITBALL_RADIUS", "maxYVelocity", "yVelocity", "randfloat", "determinant", "timeToPlayerY", "xVelocity", "numToThrow", "randint", "SpitBoss_Spit", "box", "xVel", "yVel", "parent", "Actor", "origin", "velocity", "Particle", "_playerPosition", "wallHit", "drn", "i", "vel", "hitBox", "clampPointWithin", "rectMidpoint", "insetRect", "_box", "impulse", "PitRoom", "Room", "_x", "_y", "solids", "blockers", "generateRoomForDoors", "Solid", "ROOM_SCALE_HEIGHT", "ROOM_SCALE_WIDTH", "SpitBoss", "y", "TRoom", "Room", "solids", "blockers", "generateRoomForDoors", "Solid", "ROOM_SCALE_HEIGHT", "ROOM_SCALE_WIDTH", "isDefined", "Walker", "MAP_ROOM_WIDTH", "MAP_ROOM_HEIGHT", "DEFAULT_MAP_WIDTH", "DEFAULT_MAP_HEIGHT", "MAP_ROOM_SCALE", "CURRENT_ROOM_BORDER", "INCREMENT_BY", "WorldMap", "room", "Room", "cols", "rows", "ctx", "minX", "maxX", "minY", "maxY", "x", "y", "suggestedDoors", "makeColor", "randint", "cloneDoors", "CONSTRUCTORS", "GhostRoom", "HRoom", "LRoom", "TRoom", "PitRoom", "checkDoors", "acceptableConstructors", "Class", "choices", "i", "RoomType", "width", "height", "drawWidth", "drawHeight", "xOffset", "FRAME_DURATION", "MAP_KEY", "MAP_INSET", "MAP_BORDER", "CaveWorld", "WorldMap", "latch", "ctx", "canvas", "mousePosition", "keyboardState", "currentTime", "elapsedTime", "interpolationFactor", "_canvas", "_mousePosition", "choosing", "mousingOverValidOption", "newRoom", "lastRoom", "oldPlayerEntities", "PlayerSystem", "newPlayerEntities", "oldPlayer", "newPlayer", "oldComp", "PlayerComponent", "newComp", "x", "y", "doors", "room", "i", "roomChoice", "left", "right", "middle", "height", "top", "bottom", "mouseInside", "isPointInside", "scaleFactor", "ROOM_SCALE_WIDTH", "ROOM_SCALE_HEIGHT", "main", "canvas", "ctx", "caves", "CaveWorld", "mousePosition", "e", "rect", "x", "y", "keyboardState", "loop"]
}
